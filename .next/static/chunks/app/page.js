/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fzhaojiale%2FLibrary%2FContainers%2Fcom.tencent.xinWeChat%2FData%2FLibrary%2FApplication%20Support%2Fcom.tencent.xinWeChat%2F2.0b4.0.9%2Fb065ac55dfa93c168bb482c8fdccd19e%2FMessage%2FMessageTemp%2F3cfd51035ae532f90f7e60bef55f8b76%2FFile%2Fdouyin-manage%2Fsrc%2Fapp%2Fpage.tsx&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fzhaojiale%2FLibrary%2FContainers%2Fcom.tencent.xinWeChat%2FData%2FLibrary%2FApplication%20Support%2Fcom.tencent.xinWeChat%2F2.0b4.0.9%2Fb065ac55dfa93c168bb482c8fdccd19e%2FMessage%2FMessageTemp%2F3cfd51035ae532f90f7e60bef55f8b76%2FFile%2Fdouyin-manage%2Fsrc%2Fapp%2Fpage.tsx&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnpoYW9qaWFsZSUyRkxpYnJhcnklMkZDb250YWluZXJzJTJGY29tLnRlbmNlbnQueGluV2VDaGF0JTJGRGF0YSUyRkxpYnJhcnklMkZBcHBsaWNhdGlvbiUyMFN1cHBvcnQlMkZjb20udGVuY2VudC54aW5XZUNoYXQlMkYyLjBiNC4wLjklMkZiMDY1YWM1NWRmYTkzYzE2OGJiNDgyYzhmZGNjZDE5ZSUyRk1lc3NhZ2UlMkZNZXNzYWdlVGVtcCUyRjNjZmQ1MTAzNWFlNTMyZjkwZjdlNjBiZWY1NWY4Yjc2JTJGRmlsZSUyRmRvdXlpbi1tYW5hZ2UlMkZzcmMlMkZhcHAlMkZwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YWQwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy96aGFvamlhbGUvTGlicmFyeS9Db250YWluZXJzL2NvbS50ZW5jZW50LnhpbldlQ2hhdC9EYXRhL0xpYnJhcnkvQXBwbGljYXRpb24gU3VwcG9ydC9jb20udGVuY2VudC54aW5XZUNoYXQvMi4wYjQuMC45L2IwNjVhYzU1ZGZhOTNjMTY4YmI0ODJjOGZkY2NkMTllL01lc3NhZ2UvTWVzc2FnZVRlbXAvM2NmZDUxMDM1YWU1MzJmOTBmN2U2MGJlZjU1ZjhiNzYvRmlsZS9kb3V5aW4tbWFuYWdlL3NyYy9hcHAvcGFnZS50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fzhaojiale%2FLibrary%2FContainers%2Fcom.tencent.xinWeChat%2FData%2FLibrary%2FApplication%20Support%2Fcom.tencent.xinWeChat%2F2.0b4.0.9%2Fb065ac55dfa93c168bb482c8fdccd19e%2FMessage%2FMessageTemp%2F3cfd51035ae532f90f7e60bef55f8b76%2FFile%2Fdouyin-manage%2Fsrc%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ JsonEditor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_json_editor_ajrm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-json-editor-ajrm */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/index.js\");\n/* harmony import */ var react_json_editor_ajrm_locale_en__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-json-editor-ajrm/locale/en */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/locale/en.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction JsonEditor() {\n    _s();\n    function getData() {\n        fetch(\"/api/videos\", {\n            method: \"GET\",\n            cache: \"no-cache\"\n        }).then((res)=>{\n            return res.json();\n        }).then((res)=>{\n            setJson(res.data);\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        getData();\n    }, []);\n    const [json, setJson] = react__WEBPACK_IMPORTED_MODULE_1___default().useState({});\n    function handleEdit(data) {\n        // 更新JSON数据\n        setJson(data.jsObject);\n        fetch(\"/api/videos\", {\n            method: \"POST\",\n            cache: \"no-cache\",\n            body: JSON.stringify(data.jsObject)\n        });\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_json_editor_ajrm__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n            id: \"a_unique_id\",\n            placeholder: json,\n            locale: react_json_editor_ajrm_locale_en__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n            height: \"100vh\",\n            width: \"100vw\",\n            onChange: handleEdit\n        }, void 0, false, {\n            fileName: \"/Users/zhaojiale/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/b065ac55dfa93c168bb482c8fdccd19e/Message/MessageTemp/3cfd51035ae532f90f7e60bef55f8b76/File/douyin-manage/src/app/page.tsx\",\n            lineNumber: 27,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/zhaojiale/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/b065ac55dfa93c168bb482c8fdccd19e/Message/MessageTemp/3cfd51035ae532f90f7e60bef55f8b76/File/douyin-manage/src/app/page.tsx\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, this);\n}\n_s(JsonEditor, \"AfygHUmuHcnGOyHvft/hflzpajQ=\");\n_c = JsonEditor;\nvar _c;\n$RefreshReg$(_c, \"JsonEditor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDeUM7QUFDTTtBQUNVO0FBRTFDLFNBQVNJOztJQUV0QixTQUFTQztRQUNQQyxNQUFPLGVBQWM7WUFBRUMsUUFBUTtZQUFPQyxPQUFPO1FBQVcsR0FBR0MsSUFBSSxDQUFDQyxDQUFBQTtZQUFTLE9BQU9BLElBQUlDLElBQUk7UUFBRyxHQUFHRixJQUFJLENBQUNDLENBQUFBO1lBQ2pHRSxRQUFRRixJQUFJRyxJQUFJO1FBQ2xCO0lBQ0Y7SUFFQVosZ0RBQVNBLENBQUM7UUFDUkk7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNLENBQUNNLE1BQU1DLFFBQVEsR0FBR1oscURBQWMsQ0FBQyxDQUFDO0lBRXhDLFNBQVNlLFdBQVlGLElBQUk7UUFDdkIsV0FBVztRQUNYRCxRQUFRQyxLQUFLRyxRQUFRO1FBQ3JCVixNQUFPLGVBQWM7WUFBRUMsUUFBUTtZQUFRQyxPQUFPO1lBQVlTLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ04sS0FBS0csUUFBUTtRQUFFO0lBQ2hHO0lBRUEscUJBQ0UsOERBQUNJO2tCQUNDLDRFQUFDbEIsOERBQVNBO1lBQ1JtQixJQUFjO1lBQ2RDLGFBQWdCWDtZQUNoQlIsUUFBZ0JBLHdFQUFNQTtZQUN0Qm9CLFFBQWM7WUFDZEMsT0FBYztZQUNkQyxVQUFVVjs7Ozs7Ozs7Ozs7QUFJbEI7R0EvQndCWDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3BhZ2UudHN4P2Y2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEpTT05JbnB1dCBmcm9tICdyZWFjdC1qc29uLWVkaXRvci1hanJtJztcbmltcG9ydCBsb2NhbGUgICAgZnJvbSAncmVhY3QtanNvbi1lZGl0b3ItYWpybS9sb2NhbGUvZW4nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBKc29uRWRpdG9yICgpIHtcblxuICBmdW5jdGlvbiBnZXREYXRhICgpIHtcbiAgICBmZXRjaChgL2FwaS92aWRlb3NgLCB7IG1ldGhvZDogJ0dFVCcsIGNhY2hlOiBcIm5vLWNhY2hlXCIgfSkudGhlbihyZXMgPT4geyByZXR1cm4gcmVzLmpzb24oKSB9KS50aGVuKHJlcyA9PiB7XG4gICAgICBzZXRKc29uKHJlcy5kYXRhKVxuICAgIH0pXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldERhdGEoKVxuICB9LCBbXSlcbiAgY29uc3QgW2pzb24sIHNldEpzb25dID0gUmVhY3QudXNlU3RhdGUoe30pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVkaXQgKGRhdGEpIHtcbiAgICAvLyDmm7TmlrBKU09O5pWw5o2uXG4gICAgc2V0SnNvbihkYXRhLmpzT2JqZWN0KTtcbiAgICBmZXRjaChgL2FwaS92aWRlb3NgLCB7IG1ldGhvZDogJ1BPU1QnLCBjYWNoZTogXCJuby1jYWNoZVwiLCBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhLmpzT2JqZWN0KSB9KVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPEpTT05JbnB1dFxuICAgICAgICBpZCAgICAgICAgICA9ICdhX3VuaXF1ZV9pZCdcbiAgICAgICAgcGxhY2Vob2xkZXIgPSB7IGpzb24gfVxuICAgICAgICBsb2NhbGUgICAgICA9IHsgbG9jYWxlIH1cbiAgICAgICAgaGVpZ2h0ICAgICAgPSAnMTAwdmgnXG4gICAgICAgIHdpZHRoICAgICAgID0gJzEwMHZ3J1xuICAgICAgICBvbkNoYW5nZT17aGFuZGxlRWRpdH1cbiAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwiSlNPTklucHV0IiwibG9jYWxlIiwiSnNvbkVkaXRvciIsImdldERhdGEiLCJmZXRjaCIsIm1ldGhvZCIsImNhY2hlIiwidGhlbiIsInJlcyIsImpzb24iLCJzZXRKc29uIiwiZGF0YSIsInVzZVN0YXRlIiwiaGFuZGxlRWRpdCIsImpzT2JqZWN0IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkaXYiLCJpZCIsInBsYWNlaG9sZGVyIiwiaGVpZ2h0Iiwid2lkdGgiLCJvbkNoYW5nZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsZ0RBQWdELE1BQU0sYUFBYTs7QUFFakg7QUFDQSwrQ0FBK0Msa0NBQWtDLE9BQU87O0FBRXhGLHVHQUF1RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXJRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzU3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/OGYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/err.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/err.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mitsuketa */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mitsuketa__WEBPACK_IMPORTED_MODULE_0__);\n\nconst err = {\n  getCaller: (skip = 1) => {\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    const stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: (fxName = 'unknown function', paramName = 'unknown parameter', expectation = 'to be defined') => {\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: (paramName = '<unknown parameter>', param) => {\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: (paramName = '<unknown parameter>', param) => {\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: (paramName = '<unknown parameter>', param, type = '') => {\n    if ((0,_mitsuketa__WEBPACK_IMPORTED_MODULE_0__.getType)(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: (paramName = '<unknown parameter>', param, types = []) => {\n    types.forEach(type => {\n      if ((0,_mitsuketa__WEBPACK_IMPORTED_MODULE_0__.getType)(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: (paramName = '<unknown parameter>', param, keyName = '') => {\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: (paramName = '<unknown parameter>', param, keyNames = ['']) => {\n    err.isUndefined(paramName, param);\n    const keyList = Object.keys(param);\n    keyNames.forEach(keyName => {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: (paramName = '<unknown parameter>', param) => {\n    [undefined, null].forEach(value => {\n      const location = (0,_mitsuketa__WEBPACK_IMPORTED_MODULE_0__.locate)(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(invalidChar => {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (err);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2Vyci5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxRQUFRLG1EQUFPO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLG1EQUFPO0FBQ2pCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQU07QUFDN0I7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsR0FBRztBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWpzb24tZWRpdG9yLWFqcm0vZXMvZXJyLmpzP2M3NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VHlwZSwgbG9jYXRlIH0gZnJvbSAnLi9taXRzdWtldGEnO1xuY29uc3QgZXJyID0ge1xuICBnZXRDYWxsZXI6IChza2lwID0gMSkgPT4ge1xuICAgIC8vIEEgc29tZXdoYXQgaGFja3kgc29sdXRpb24gdGhhdCB3aWxsIHlpZWxkIGRpZmZlcmVudCByZXN1bHRzIGluIGRpZmZlcmVudCBKUyBlbmdpbmVzLiBcbiAgICAvLyBTaW5jZSB3ZSBvbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIGFuIGVycm9yIHdpbGwgYWN0dWFsbHkgYmUgdGhyb3duIHdlIHR5cGljYWxseSBkb24ndCBcbiAgICAvLyByYWxseSBtaW5kIHRoZSBwZXJmb3JtYW5jZSBpbXBhY3QgdGhpcyBtaWdodCBoYXZlIGlmIGNhbGxlZCB0b28gb2Z0ZW4uXG4gICAgLy8gTHVja3kgZm9yIHVzIHdlIHVzZSBub2RlSlMgYW5kIHRodXMgb25seSBWOC5cbiAgICBjb25zdCBzdGFja1RyYWNlID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgdmFyIGNhbGxlck5hbWUgPSBzdGFja1RyYWNlLnJlcGxhY2UoL15FcnJvclxccysvLCAnJyk7XG4gICAgY2FsbGVyTmFtZSA9IGNhbGxlck5hbWUuc3BsaXQoXCJcXG5cIilbc2tpcF07XG4gICAgY2FsbGVyTmFtZSA9IGNhbGxlck5hbWUucmVwbGFjZSgvXlxccythdCBPYmplY3QuLywgJycpLnJlcGxhY2UoL15cXHMrYXQgLywgJycpLnJlcGxhY2UoLyBcXCguK1xcKSQvLCAnJyk7XG4gICAgcmV0dXJuIGNhbGxlck5hbWU7XG4gIH0sXG4gIHRocm93RXJyb3I6IChmeE5hbWUgPSAndW5rbm93biBmdW5jdGlvbicsIHBhcmFtTmFtZSA9ICd1bmtub3duIHBhcmFtZXRlcicsIGV4cGVjdGF0aW9uID0gJ3RvIGJlIGRlZmluZWQnKSA9PiB7XG4gICAgdGhyb3cgWydAJywgZnhOYW1lLCAnKCk6IEV4cGVjdGVkIHBhcmFtZXRlciBcXCcnLCBwYXJhbU5hbWUsICdcXCcgJywgZXhwZWN0YXRpb25dLmpvaW4oJycpO1xuICB9LFxuICBpc1VuZGVmaW5lZDogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0pID0+IHtcbiAgICBpZiAoW251bGwsIHVuZGVmaW5lZF0uaW5kZXhPZihwYXJhbSkgPiAtMSkgZXJyLnRocm93RXJyb3IoZXJyLmdldENhbGxlcigyKSwgcGFyYW1OYW1lKTtcbiAgfSxcbiAgaXNGYWxzeTogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0pID0+IHtcbiAgICBpZiAoIXBhcmFtKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUpO1xuICB9LFxuICBpc05vbmVPZjogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0sIGNvbnRhaW5zID0gW10pID0+IHtcbiAgICBpZiAoY29udGFpbnMuaW5kZXhPZihwYXJhbSkgPT09IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICd0byBiZSBhbnkgb2YnICsgSlNPTi5zdHJpbmdpZnkoY29udGFpbnMpKTtcbiAgfSxcbiAgaXNBbnlPZjogKHBhcmFtTmFtZSA9ICc8dW5rbm93biBwYXJhbWV0ZXI+JywgcGFyYW0sIGNvbnRhaW5zID0gW10pID0+IHtcbiAgICBpZiAoY29udGFpbnMuaW5kZXhPZihwYXJhbSkgPiAtMSkgZXJyLnRocm93RXJyb3IoZXJyLmdldENhbGxlcigyKSwgcGFyYW1OYW1lLCAnbm90IHRvIGJlIGFueSBvZicgKyBKU09OLnN0cmluZ2lmeShjb250YWlucykpO1xuICB9LFxuICBpc05vdFR5cGU6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtLCB0eXBlID0gJycpID0+IHtcbiAgICBpZiAoZ2V0VHlwZShwYXJhbSkgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkgZXJyLnRocm93RXJyb3IoZXJyLmdldENhbGxlcigyKSwgcGFyYW1OYW1lLCAndG8gYmUgdHlwZSAnICsgdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgaXNBbnlUeXBlT2Y6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtLCB0eXBlcyA9IFtdKSA9PiB7XG4gICAgdHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGlmIChnZXRUeXBlKHBhcmFtKSA9PT0gdHlwZSkgZXJyLnRocm93RXJyb3IoZXJyLmdldENhbGxlcigyKSwgcGFyYW1OYW1lLCAnbm90IHRvIGJlIHR5cGUgb2YgJyArIHR5cGUudG9Mb3dlckNhc2UoKSk7XG4gICAgfSk7XG4gIH0sXG4gIG1pc3NpbmdLZXk6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtLCBrZXlOYW1lID0gJycpID0+IHtcbiAgICBlcnIuaXNVbmRlZmluZWQocGFyYW1OYW1lLCBwYXJhbSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtKS5pbmRleE9mKGtleU5hbWUpID09PSAtMSkgZXJyLnRocm93RXJyb3IoZXJyLmdldENhbGxlcigyKSwgcGFyYW1OYW1lLCAndG8gY29udGFpbiBcXCcnICsga2V5TmFtZSArICdcXCcga2V5Jyk7XG4gIH0sXG4gIG1pc3NpbmdBbnlLZXlzOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSwga2V5TmFtZXMgPSBbJyddKSA9PiB7XG4gICAgZXJyLmlzVW5kZWZpbmVkKHBhcmFtTmFtZSwgcGFyYW0pO1xuICAgIGNvbnN0IGtleUxpc3QgPSBPYmplY3Qua2V5cyhwYXJhbSk7XG4gICAga2V5TmFtZXMuZm9yRWFjaChrZXlOYW1lID0+IHtcbiAgICAgIGlmIChrZXlMaXN0LmluZGV4T2Yoa2V5TmFtZSkgPT09IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICd0byBjb250YWluIFxcJycgKyBrZXlOYW1lICsgJ1xcJyBrZXknKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udGFpbnNVbmRlZmluZWQ6IChwYXJhbU5hbWUgPSAnPHVua25vd24gcGFyYW1ldGVyPicsIHBhcmFtKSA9PiB7XG4gICAgW3VuZGVmaW5lZCwgbnVsbF0uZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0ZShwYXJhbSwgdmFsdWUpO1xuICAgICAgaWYgKGxvY2F0aW9uKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICdub3QgdG8gY29udGFpbiBcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcJyBhdCAnICsgbG9jYXRpb24pO1xuICAgIH0pO1xuICB9LFxuICBpc0ludmFsaWRQYXRoOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSkgPT4ge1xuICAgIGVyci5pc1VuZGVmaW5lZChwYXJhbU5hbWUsIHBhcmFtKTtcbiAgICBlcnIuaXNOb3RUeXBlKHBhcmFtTmFtZSwgcGFyYW0sICdzdHJpbmcnKTtcbiAgICBlcnIuaXNBbnlPZihwYXJhbU5hbWUsIHBhcmFtLCBbJycsICcvJ10pO1xuICAgICcuJFtdIycuc3BsaXQoKS5mb3JFYWNoKGludmFsaWRDaGFyID0+IHtcbiAgICAgIGlmIChwYXJhbS5pbmRleE9mKGludmFsaWRDaGFyKSA+IC0xKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICdub3QgdG8gY29udGFpbiBpbnZhbGlkIGNoYXJhY3RlciBcXCcnICsgaW52YWxpZENoYXIgKyAnXFwnJyk7XG4gICAgfSk7XG4gICAgaWYgKHBhcmFtLm1hdGNoKC9cXC97Mix9L2cpKSBlcnIudGhyb3dFcnJvcihlcnIuZ2V0Q2FsbGVyKDIpLCBwYXJhbU5hbWUsICdub3QgdG8gY29udGFpbiBjb25zZWN1dGl2ZSBmb3J3YXJkIHNsYXNoIGNoYXJhY3RlcnMnKTtcbiAgfSxcbiAgaXNJbnZhbGlkV3JpdGVEYXRhOiAocGFyYW1OYW1lID0gJzx1bmtub3duIHBhcmFtZXRlcj4nLCBwYXJhbSkgPT4ge1xuICAgIGVyci5pc1VuZGVmaW5lZChwYXJhbU5hbWUsIHBhcmFtKTtcbiAgICBlcnIuY29udGFpbnNVbmRlZmluZWQocGFyYW1OYW1lLCBwYXJhbSk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBlcnI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/err.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./themes */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/themes.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mitsuketa */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\");\n/* harmony import */ var _mitsuketa__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_mitsuketa__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _err__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./err */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/err.js\");\n/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./locale */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/index.js\");\n/* harmony import */ var _locale_en__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./locale/en */ \"(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/en.js\");\n/** @license react-json-editor-ajrm v2.5.14\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\nclass JSONInput extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(props) {\n    super(props);\n    this.updateInternalProps = this.updateInternalProps.bind(this);\n    this.createMarkup = this.createMarkup.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onBlur = this.onBlur.bind(this);\n    this.update = this.update.bind(this);\n    this.getCursorPosition = this.getCursorPosition.bind(this);\n    this.setCursorPosition = this.setCursorPosition.bind(this);\n    this.scheduledUpdate = this.scheduledUpdate.bind(this);\n    this.setUpdateTime = this.setUpdateTime.bind(this);\n    this.renderLabels = this.renderLabels.bind(this);\n    this.newSpan = this.newSpan.bind(this);\n    this.renderErrorMessage = this.renderErrorMessage.bind(this);\n    this.onScroll = this.onScroll.bind(this);\n    this.showPlaceholder = this.showPlaceholder.bind(this);\n    this.tokenize = this.tokenize.bind(this);\n    this.onKeyPress = this.onKeyPress.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onPaste = this.onPaste.bind(this);\n    this.stopEvent = this.stopEvent.bind(this);\n    this.refContent = null;\n    this.refLabels = null;\n    this.updateInternalProps();\n    this.renderCount = 1;\n    this.state = {\n      prevPlaceholder: '',\n      markupText: '',\n      plainText: '',\n      json: '',\n      jsObject: undefined,\n      lines: false,\n      error: false\n    };\n\n    if (!this.props.locale) {\n      console.warn(\"[react-json-editor-ajrm - Deprecation Warning] You did not provide a 'locale' prop for your JSON input - This will be required in a future version. English has been set as a default.\");\n    }\n  }\n\n  updateInternalProps() {\n    let colors = {},\n        style = {},\n        theme = _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"].dark_vscode_tribute;\n    if ('theme' in this.props) if (typeof this.props.theme === 'string') if (this.props.theme in _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) theme = _themes__WEBPACK_IMPORTED_MODULE_2__[\"default\"][this.props.theme];\n    colors = theme;\n    if ('colors' in this.props) colors = {\n      default: 'default' in this.props.colors ? this.props.colors.default : colors.default,\n      string: 'string' in this.props.colors ? this.props.colors.string : colors.string,\n      number: 'number' in this.props.colors ? this.props.colors.number : colors.number,\n      colon: 'colon' in this.props.colors ? this.props.colors.colon : colors.colon,\n      keys: 'keys' in this.props.colors ? this.props.colors.keys : colors.keys,\n      keys_whiteSpace: 'keys_whiteSpace' in this.props.colors ? this.props.colors.keys_whiteSpace : colors.keys_whiteSpace,\n      primitive: 'primitive' in this.props.colors ? this.props.colors.primitive : colors.primitive,\n      error: 'error' in this.props.colors ? this.props.colors.error : colors.error,\n      background: 'background' in this.props.colors ? this.props.colors.background : colors.background,\n      background_warning: 'background_warning' in this.props.colors ? this.props.colors.background_warning : colors.background_warning\n    };\n    this.colors = colors;\n    if ('style' in this.props) style = {\n      outerBox: 'outerBox' in this.props.style ? this.props.style.outerBox : {},\n      container: 'container' in this.props.style ? this.props.style.container : {},\n      warningBox: 'warningBox' in this.props.style ? this.props.style.warningBox : {},\n      errorMessage: 'errorMessage' in this.props.style ? this.props.style.errorMessage : {},\n      body: 'body' in this.props.style ? this.props.style.body : {},\n      labelColumn: 'labelColumn' in this.props.style ? this.props.style.labelColumn : {},\n      labels: 'labels' in this.props.style ? this.props.style.labels : {},\n      contentBox: 'contentBox' in this.props.style ? this.props.style.contentBox : {}\n    };else style = {\n      outerBox: {},\n      container: {},\n      warningBox: {},\n      errorMessage: {},\n      body: {},\n      labelColumn: {},\n      labels: {},\n      contentBox: {}\n    };\n    this.style = style;\n    this.confirmGood = 'confirmGood' in this.props ? this.props.confirmGood : true;\n    const totalHeight = this.props.height || '610px',\n          totalWidth = this.props.width || '479px';\n    this.totalHeight = totalHeight;\n    this.totalWidth = totalWidth;\n\n    if (!('onKeyPressUpdate' in this.props) || this.props.onKeyPressUpdate) {\n      if (!this.timer) this.timer = setInterval(this.scheduledUpdate, 100);\n    } else if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = false;\n    }\n\n    this.updateTime = false;\n    this.waitAfterKeyPress = 'waitAfterKeyPress' in this.props ? this.props.waitAfterKeyPress : 1000;\n    this.resetConfiguration = 'reset' in this.props ? this.props.reset : false;\n  }\n\n  render() {\n    const id = this.props.id,\n          markupText = this.state.markupText,\n          error = this.props.error || this.state.error,\n          colors = this.colors,\n          style = this.style,\n          confirmGood = this.confirmGood,\n          totalHeight = this.totalHeight,\n          totalWidth = this.totalWidth,\n          hasError = !!this.props.error || (error ? 'token' in error : false);\n    this.renderCount++;\n    return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      name: \"outer-box\",\n      id: id && id + '-outer-box',\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        overflow: 'none',\n        height: totalHeight,\n        width: totalWidth,\n        margin: 0,\n        boxSizing: 'border-box',\n        position: 'relative'\n      }, style.outerBox)\n    }, confirmGood ? react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      style: {\n        opacity: hasError ? 0 : 1,\n        height: '30px',\n        width: '30px',\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        transform: 'translate(-25%,25%)',\n        pointerEvents: 'none',\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"svg\", {\n      height: \"30px\",\n      width: \"30px\",\n      viewBox: \"0 0 100 100\"\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      fill: \"green\",\n      opacity: \"0.85\",\n      d: \"M39.363,79L16,55.49l11.347-11.419L39.694,56.49L72.983,23L84,34.085L39.363,79z\"\n    }))) : void 0, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      name: \"container\",\n      id: id && id + '-container',\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        height: totalHeight,\n        width: totalWidth,\n        margin: 0,\n        boxSizing: 'border-box',\n        overflow: 'hidden',\n        fontFamily: 'Roboto, sans-serif'\n      }, style.container),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      name: \"warning-box\",\n      id: id && id + '-warning-box',\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'block',\n        overflow: 'hidden',\n        height: hasError ? '60px' : '0px',\n        width: '100%',\n        margin: 0,\n        backgroundColor: colors.background_warning,\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }, style.warningBox),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", {\n      style: {\n        display: 'inline-block',\n        height: '60px',\n        width: '60px',\n        margin: 0,\n        boxSizing: 'border-box',\n        overflow: 'hidden',\n        verticalAlign: 'top',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      style: {\n        position: 'relative',\n        top: 0,\n        left: 0,\n        height: '60px',\n        width: '60px',\n        margin: 0,\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      style: {\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        transform: 'translate(-50%, -50%)',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"svg\", {\n      height: \"25px\",\n      width: \"25px\",\n      viewBox: \"0 0 100 100\"\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"path\", {\n      fillRule: \"evenodd\",\n      clipRule: \"evenodd\",\n      fill: \"red\",\n      d: \"M73.9,5.75c0.467-0.467,1.067-0.7,1.8-0.7c0.7,0,1.283,0.233,1.75,0.7l16.8,16.8  c0.467,0.5,0.7,1.084,0.7,1.75c0,0.733-0.233,1.334-0.7,1.801L70.35,50l23.9,23.95c0.5,0.467,0.75,1.066,0.75,1.8  c0,0.667-0.25,1.25-0.75,1.75l-16.8,16.75c-0.534,0.467-1.117,0.7-1.75,0.7s-1.233-0.233-1.8-0.7L50,70.351L26.1,94.25  c-0.567,0.467-1.167,0.7-1.8,0.7c-0.667,0-1.283-0.233-1.85-0.7L5.75,77.5C5.25,77,5,76.417,5,75.75c0-0.733,0.25-1.333,0.75-1.8  L29.65,50L5.75,26.101C5.25,25.667,5,25.066,5,24.3c0-0.666,0.25-1.25,0.75-1.75l16.8-16.8c0.467-0.467,1.05-0.7,1.75-0.7  c0.733,0,1.333,0.233,1.8,0.7L50,29.65L73.9,5.75z\"\n    }))))), react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", {\n      style: {\n        display: 'inline-block',\n        height: '60px',\n        width: 'calc(100% - 60px)',\n        margin: 0,\n        overflow: 'hidden',\n        verticalAlign: 'top',\n        position: 'absolute',\n        pointerEvents: 'none'\n      },\n      onClick: this.onClick\n    }, this.renderErrorMessage())), react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n      name: \"body\",\n      id: id && id + '-body',\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'flex',\n        overflow: 'none',\n        height: hasError ? 'calc(100% - 60px)' : '100%',\n        width: '',\n        margin: 0,\n        resize: 'none',\n        fontFamily: 'Roboto Mono, Monaco, monospace',\n        fontSize: '11px',\n        backgroundColor: colors.background,\n        transitionDuration: '0.2s',\n        transitionTimingFunction: 'cubic-bezier(0, 1, 0.5, 1)'\n      }, style.body),\n      onClick: this.onClick\n    }, react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", {\n      name: \"labels\",\n      id: id && id + '-labels',\n      ref: ref => this.refLabels = ref,\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'inline-block',\n        boxSizing: 'border-box',\n        verticalAlign: 'top',\n        height: '100%',\n        width: '44px',\n        margin: 0,\n        padding: '5px 0px 5px 10px',\n        overflow: 'hidden',\n        color: '#D4D4D4'\n      }, style.labelColumn),\n      onClick: this.onClick\n    }, this.renderLabels()), react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", {\n      id: id,\n      ref: ref => this.refContent = ref,\n      contentEditable: true,\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        display: 'inline-block',\n        boxSizing: 'border-box',\n        verticalAlign: 'top',\n        height: '100%',\n        width: '',\n        flex: 1,\n        margin: 0,\n        padding: '5px',\n        overflowX: 'hidden',\n        overflowY: 'auto',\n        wordWrap: 'break-word',\n        whiteSpace: 'pre-line',\n        color: '#D4D4D4',\n        outline: 'none'\n      }, style.contentBox),\n      dangerouslySetInnerHTML: this.createMarkup(markupText),\n      onKeyPress: this.onKeyPress,\n      onKeyDown: this.onKeyDown,\n      onClick: this.onClick,\n      onBlur: this.onBlur,\n      onScroll: this.onScroll,\n      onPaste: this.onPaste,\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      autoCapitalize: \"off\",\n      spellCheck: false\n    }))));\n  }\n\n  renderErrorMessage() {\n    const locale = this.props.locale || _locale_en__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n          error = this.props.error || this.state.error,\n          style = this.style;\n    if (!error) return void 0;\n    return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"p\", {\n      style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        color: 'red',\n        fontSize: '12px',\n        position: 'absolute',\n        width: 'calc(100% - 60px)',\n        height: '60px',\n        boxSizing: 'border-box',\n        margin: 0,\n        padding: 0,\n        paddingRight: '10px',\n        overflowWrap: 'break-word',\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center'\n      }, style.errorMessage)\n    }, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.format, error));\n  }\n\n  renderLabels() {\n    const colors = this.colors,\n          style = this.style,\n          error = this.props.error || this.state.error,\n          errorLine = error ? error.line : -1,\n          lines = this.state.lines ? this.state.lines : 1;\n    let labels = new Array(lines);\n\n    for (var i = 0; i < lines - 1; i++) labels[i] = i + 1;\n\n    return labels.map(number => {\n      const color = number !== errorLine ? colors.default : 'red';\n      return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", {\n        key: number,\n        style: (0,_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, style.labels, {\n          color: color\n        })\n      }, number);\n    });\n  }\n\n  createMarkup(markupText) {\n    if (markupText === undefined) return {\n      __html: ''\n    };\n    return {\n      __html: '' + markupText\n    };\n  }\n\n  newSpan(i, token, depth) {\n    let colors = this.colors,\n        type = token.type,\n        string = token.string;\n    let color = '';\n\n    switch (type) {\n      case 'string':\n      case 'number':\n      case 'primitive':\n      case 'error':\n        color = colors[token.type];\n        break;\n\n      case 'key':\n        if (string === ' ') color = colors.keys_whiteSpace;else color = colors.keys;\n        break;\n\n      case 'symbol':\n        if (string === ':') color = colors.colon;else color = colors.default;\n        break;\n\n      default:\n        color = colors.default;\n        break;\n    }\n\n    if (string.length !== string.replace(/</g, '').replace(/>/g, '').length) string = '<xmp style=display:inline;>' + string + '</xmp>';\n    return '<span' + ' type=\"' + type + '\"' + ' value=\"' + string + '\"' + ' depth=\"' + depth + '\"' + ' style=\"color:' + color + '\"' + '>' + string + '</span>';\n  }\n\n  getCursorPosition(countBR) {\n    /**\r\n     * Need to deprecate countBR\r\n     * It is used to differenciate between good markup render, and aux render when error found\r\n     * Adjustments based on coundBR account for usage of <br> instead of <span> for linebreaks to determine acurate cursor position\r\n     * Find a way to consolidate render styles\r\n     */\n    const isChildOf = node => {\n      while (node !== null) {\n        if (node === this.refContent) return true;\n        node = node.parentNode;\n      }\n\n      return false;\n    };\n\n    let selection = window.getSelection(),\n        charCount = -1,\n        linebreakCount = 0,\n        node;\n\n    if (selection.focusNode && isChildOf(selection.focusNode)) {\n      node = selection.focusNode;\n      charCount = selection.focusOffset;\n\n      while (node) {\n        if (node === this.refContent) break;\n\n        if (node.previousSibling) {\n          node = node.previousSibling;\n          if (countBR) if (node.nodeName === 'BR') linebreakCount++;\n          charCount += node.textContent.length;\n        } else {\n          node = node.parentNode;\n          if (node === null) break;\n        }\n      }\n    }\n\n    return charCount + linebreakCount;\n  }\n\n  setCursorPosition(nextPosition) {\n    if ([false, null, undefined].indexOf(nextPosition) > -1) return;\n\n    const createRange = (node, chars, range) => {\n      if (!range) {\n        range = document.createRange();\n        range.selectNode(node);\n        range.setStart(node, 0);\n      }\n\n      if (chars.count === 0) {\n        range.setEnd(node, chars.count);\n      } else if (node && chars.count > 0) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          if (node.textContent.length < chars.count) chars.count -= node.textContent.length;else {\n            range.setEnd(node, chars.count);\n            chars.count = 0;\n          }\n        } else for (var lp = 0; lp < node.childNodes.length; lp++) {\n          range = createRange(node.childNodes[lp], chars, range);\n          if (chars.count === 0) break;\n        }\n      }\n\n      return range;\n    };\n\n    const setPosition = chars => {\n      if (chars < 0) return;\n      let selection = window.getSelection(),\n          range = createRange(this.refContent, {\n        count: chars\n      });\n      if (!range) return;\n      range.collapse(false);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    };\n\n    if (nextPosition > 0) setPosition(nextPosition);else this.refContent.focus();\n  }\n\n  update(cursorOffset = 0, updateCursorPosition = true) {\n    const container = this.refContent,\n          data = this.tokenize(container);\n    if ('onChange' in this.props) this.props.onChange({\n      plainText: data.indented,\n      markupText: data.markup,\n      json: data.json,\n      jsObject: data.jsObject,\n      lines: data.lines,\n      error: data.error\n    });\n    let cursorPosition = this.getCursorPosition(data.error) + cursorOffset;\n    this.setState({\n      plainText: data.indented,\n      markupText: data.markup,\n      json: data.json,\n      jsObject: data.jsObject,\n      lines: data.lines,\n      error: data.error\n    });\n    this.updateTime = false;\n    if (updateCursorPosition) this.setCursorPosition(cursorPosition);\n  }\n\n  scheduledUpdate() {\n    if ('onKeyPressUpdate' in this.props) if (this.props.onKeyPressUpdate === false) return;\n    const {\n      updateTime\n    } = this;\n    if (updateTime === false) return;\n    if (updateTime > new Date().getTime()) return;\n    this.update();\n  }\n\n  setUpdateTime() {\n    if ('onKeyPressUpdate' in this.props) if (this.props.onKeyPressUpdate === false) return;\n    this.updateTime = new Date().getTime() + this.waitAfterKeyPress;\n  }\n\n  stopEvent(event) {\n    if (!event) return;\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  onKeyPress(event) {\n    const ctrlOrMetaIsPressed = event.ctrlKey || event.metaKey;\n    if (this.props.viewOnly && !ctrlOrMetaIsPressed) this.stopEvent(event);\n    if (!ctrlOrMetaIsPressed) this.setUpdateTime();\n  }\n\n  onKeyDown(event) {\n    const viewOnly = !!this.props.viewOnly;\n    const ctrlOrMetaIsPressed = event.ctrlKey || event.metaKey;\n\n    switch (event.key) {\n      case 'Tab':\n        this.stopEvent(event);\n        if (viewOnly) break;\n        document.execCommand(\"insertText\", false, \"  \");\n        this.setUpdateTime();\n        break;\n\n      case 'Backspace':\n      case 'Delete':\n        if (viewOnly) this.stopEvent(event);\n        this.setUpdateTime();\n        break;\n\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'ArrowUp':\n      case 'ArrowDown':\n        this.setUpdateTime();\n        break;\n\n      case 'a':\n      case 'c':\n        if (viewOnly && !ctrlOrMetaIsPressed) this.stopEvent(event);\n        break;\n\n      default:\n        if (viewOnly) this.stopEvent(event);\n        break;\n    }\n  }\n\n  onPaste(event) {\n    if (this.props.viewOnly) {\n      this.stopEvent(event);\n    } else {\n      event.preventDefault();\n      var text = event.clipboardData.getData('text/plain');\n      document.execCommand('insertText', false, text);\n    }\n\n    this.update();\n  }\n\n  onClick() {\n    if ('viewOnly' in this.props) if (this.props.viewOnly) return;\n  }\n\n  onBlur() {\n    if ('viewOnly' in this.props) if (this.props.viewOnly) return;\n    const container = this.refContent,\n          data = this.tokenize(container);\n    if ('onBlur' in this.props) this.props.onBlur({\n      plainText: data.indented,\n      markupText: data.markup,\n      json: data.json,\n      jsObject: data.jsObject,\n      lines: data.lines,\n      error: data.error\n    });\n  }\n\n  onScroll(event) {\n    this.refLabels.scrollTop = event.target.scrollTop;\n  }\n\n  componentDidUpdate() {\n    this.updateInternalProps();\n    this.showPlaceholder();\n  }\n\n  componentDidMount() {\n    this.showPlaceholder();\n  }\n\n  componentWillUnmount() {\n    if (this.timer) clearInterval(this.timer);\n  }\n\n  showPlaceholder() {\n    const placeholderDoesNotExist = !('placeholder' in this.props);\n    if (placeholderDoesNotExist) return;\n    const {\n      placeholder\n    } = this.props;\n    const placeholderHasEmptyValues = [undefined, null].indexOf(placeholder) > -1;\n    if (placeholderHasEmptyValues) return;\n    const {\n      prevPlaceholder,\n      jsObject\n    } = this.state;\n    const {\n      resetConfiguration\n    } = this;\n    const placeholderDataType = (0,_mitsuketa__WEBPACK_IMPORTED_MODULE_5__.getType)(placeholder);\n    const unexpectedDataType = ['object', 'array'].indexOf(placeholderDataType) === -1;\n    if (unexpectedDataType) _err__WEBPACK_IMPORTED_MODULE_6__[\"default\"].throwError('showPlaceholder', 'placeholder', 'either an object or an array');\n    const samePlaceholderValues = (0,_mitsuketa__WEBPACK_IMPORTED_MODULE_5__.identical)(placeholder, prevPlaceholder); // Component will always re-render when new placeholder value is any different from previous placeholder value.\n\n    let componentShouldUpdate = !samePlaceholderValues;\n\n    if (!componentShouldUpdate) {\n      if (resetConfiguration) {\n        /**\r\n         * If 'reset' property is set true or is truthy,\r\n         * any difference between placeholder and current value\r\n         * should trigger component re-render\r\n         */\n        if (jsObject !== undefined) componentShouldUpdate = !(0,_mitsuketa__WEBPACK_IMPORTED_MODULE_5__.identical)(placeholder, jsObject);\n      }\n    }\n\n    if (!componentShouldUpdate) return;\n    const data = this.tokenize(placeholder);\n    this.setState({\n      prevPlaceholder: placeholder,\n      plainText: data.indentation,\n      markupText: data.markup,\n      lines: data.lines,\n      error: data.error\n    });\n  }\n\n  tokenize(something) {\n    if (typeof something !== 'object') return console.error('tokenize() expects object type properties only. Got \\'' + typeof something + '\\' type instead.');\n    const locale = this.props.locale || _locale_en__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n    const newSpan = this.newSpan;\n    /**\r\n     *     DOM NODE || ONBLUR OR UPDATE\r\n     */\n\n    if ('nodeType' in something) {\n      const containerNode = something.cloneNode(true),\n            hasChildren = containerNode.hasChildNodes();\n      if (!hasChildren) return '';\n      const children = containerNode.childNodes;\n      let buffer = {\n        tokens_unknown: [],\n        tokens_proto: [],\n        tokens_split: [],\n        tokens_fallback: [],\n        tokens_normalize: [],\n        tokens_merge: [],\n        tokens_plainText: '',\n        indented: '',\n        json: '',\n        jsObject: undefined,\n        markup: ''\n      };\n\n      for (var i = 0; i < children.length; i++) {\n        let child = children[i];\n        let info = {};\n\n        switch (child.nodeName) {\n          case 'SPAN':\n            info = {\n              string: child.textContent,\n              type: child.attributes.type.textContent\n            };\n            buffer.tokens_unknown.push(info);\n            break;\n\n          case 'DIV':\n            buffer.tokens_unknown.push({\n              string: child.textContent,\n              type: 'unknown'\n            });\n            break;\n\n          case 'BR':\n            if (child.textContent === '') buffer.tokens_unknown.push({\n              string: '\\n',\n              type: 'unknown'\n            });\n            break;\n\n          case '#text':\n            buffer.tokens_unknown.push({\n              string: child.wholeText,\n              type: 'unknown'\n            });\n            break;\n\n          case 'FONT':\n            buffer.tokens_unknown.push({\n              string: child.textContent,\n              type: 'unknown'\n            });\n            break;\n\n          default:\n            console.error('Unrecognized node:', {\n              child\n            });\n            break;\n        }\n      }\n\n      function quarkize(text, prefix = '') {\n        let buffer = {\n          active: false,\n          string: '',\n          number: '',\n          symbol: '',\n          space: '',\n          delimiter: '',\n          quarks: []\n        };\n\n        function pushAndStore(char, type) {\n          switch (type) {\n            case 'symbol':\n            case 'delimiter':\n              if (buffer.active) buffer.quarks.push({\n                string: buffer[buffer.active],\n                type: prefix + '-' + buffer.active\n              });\n              buffer[buffer.active] = '';\n              buffer.active = type;\n              buffer[buffer.active] = char;\n              break;\n\n            default:\n              if (type !== buffer.active || [buffer.string, char].indexOf('\\n') > -1) {\n                if (buffer.active) buffer.quarks.push({\n                  string: buffer[buffer.active],\n                  type: prefix + '-' + buffer.active\n                });\n                buffer[buffer.active] = '';\n                buffer.active = type;\n                buffer[buffer.active] = char;\n              } else buffer[type] += char;\n\n              break;\n          }\n        }\n\n        function finalPush() {\n          if (buffer.active) {\n            buffer.quarks.push({\n              string: buffer[buffer.active],\n              type: prefix + '-' + buffer.active\n            });\n            buffer[buffer.active] = '';\n            buffer.active = false;\n          }\n        }\n\n        for (var i = 0; i < text.length; i++) {\n          const char = text.charAt(i);\n\n          switch (char) {\n            case '\"':\n            case \"'\":\n              pushAndStore(char, 'delimiter');\n              break;\n\n            case ' ':\n            case '\\u00A0':\n              pushAndStore(char, 'space');\n              break;\n\n            case '{':\n            case '}':\n            case '[':\n            case ']':\n            case ':':\n            case ',':\n              pushAndStore(char, 'symbol');\n              break;\n\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              if (buffer.active === 'string') pushAndStore(char, 'string');else pushAndStore(char, 'number');\n              break;\n\n            case '-':\n              if (i < text.length - 1) if ('0123456789'.indexOf(text.charAt(i + 1)) > -1) {\n                pushAndStore(char, 'number');\n                break;\n              }\n\n            case '.':\n              if (i < text.length - 1 && i > 0) if ('0123456789'.indexOf(text.charAt(i + 1)) > -1 && '0123456789'.indexOf(text.charAt(i - 1)) > -1) {\n                pushAndStore(char, 'number');\n                break;\n              }\n\n            default:\n              pushAndStore(char, 'string');\n              break;\n          }\n        }\n\n        finalPush();\n        return buffer.quarks;\n      }\n\n      for (var i = 0; i < buffer.tokens_unknown.length; i++) {\n        let token = buffer.tokens_unknown[i];\n        buffer.tokens_proto = buffer.tokens_proto.concat(quarkize(token.string, 'proto'));\n      }\n\n      function validToken(string, type) {\n        const quotes = '\\'\"';\n        let firstChar = '',\n            lastChar = '',\n            quoteType = false;\n\n        switch (type) {\n          case 'primitive':\n            if (['true', 'false', 'null', 'undefined'].indexOf(string) === -1) return false;\n            break;\n\n          case 'string':\n            if (string.length < 2) return false;\n            firstChar = string.charAt(0), lastChar = string.charAt(string.length - 1), quoteType = quotes.indexOf(firstChar);\n            if (quoteType === -1) return false;\n            if (firstChar !== lastChar) return false;\n\n            for (var i = 0; i < string.length; i++) {\n              if (i > 0 && i < string.length - 1) if (string.charAt(i) === quotes[quoteType]) if (string.charAt(i - 1) !== '\\\\') return false;\n            }\n\n            break;\n\n          case 'key':\n            if (string.length === 0) return false;\n            firstChar = string.charAt(0), lastChar = string.charAt(string.length - 1), quoteType = quotes.indexOf(firstChar);\n\n            if (quoteType > -1) {\n              if (string.length === 1) return false;\n              if (firstChar !== lastChar) return false;\n\n              for (var i = 0; i < string.length; i++) {\n                if (i > 0 && i < string.length - 1) if (string.charAt(i) === quotes[quoteType]) if (string.charAt(i - 1) !== '\\\\') return false;\n              }\n            } else {\n              const nonAlphanumeric = '\\'\"`.,:;{}[]&<>=~*%\\\\|/-+!?@^ \\xa0';\n\n              for (var i = 0; i < nonAlphanumeric.length; i++) {\n                const nonAlpha = nonAlphanumeric.charAt(i);\n                if (string.indexOf(nonAlpha) > -1) return false;\n              }\n            }\n\n            break;\n\n          case 'number':\n            for (var i = 0; i < string.length; i++) {\n              if ('0123456789'.indexOf(string.charAt(i)) === -1) if (i === 0) {\n                if ('-' !== string.charAt(0)) return false;\n              } else if ('.' !== string.charAt(i)) return false;\n            }\n\n            break;\n\n          case 'symbol':\n            if (string.length > 1) return false;\n            if ('{[:]},'.indexOf(string) === -1) return false;\n            break;\n\n          case 'colon':\n            if (string.length > 1) return false;\n            if (':' !== string) return false;\n            break;\n\n          default:\n            return true;\n            break;\n        }\n\n        return true;\n      }\n\n      for (var i = 0; i < buffer.tokens_proto.length; i++) {\n        let token = buffer.tokens_proto[i];\n\n        if (token.type.indexOf('proto') === -1) {\n          if (!validToken(token.string, token.type)) {\n            buffer.tokens_split = buffer.tokens_split.concat(quarkize(token.string, 'split'));\n          } else buffer.tokens_split.push(token);\n        } else buffer.tokens_split.push(token);\n      }\n\n      for (var i = 0; i < buffer.tokens_split.length; i++) {\n        let token = buffer.tokens_split[i];\n        let type = token.type,\n            string = token.string,\n            length = string.length,\n            fallback = [];\n\n        if (type.indexOf('-') > -1) {\n          type = type.slice(type.indexOf('-') + 1);\n          if (type !== 'string') fallback.push('string');\n          fallback.push('key');\n          fallback.push('error');\n        }\n\n        let tokul = {\n          string: string,\n          length: length,\n          type: type,\n          fallback: fallback\n        };\n        buffer.tokens_fallback.push(tokul);\n      }\n\n      function tokenFollowed() {\n        const last = buffer.tokens_normalize.length - 1;\n        if (last < 1) return false;\n\n        for (var i = last; i >= 0; i--) {\n          const previousToken = buffer.tokens_normalize[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            default:\n              return previousToken;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      let buffer2 = {\n        brackets: [],\n        stringOpen: false,\n        isValue: false\n      };\n\n      for (var i = 0; i < buffer.tokens_fallback.length; i++) {\n        let token = buffer.tokens_fallback[i];\n        const type = token.type,\n              string = token.string;\n        let normalToken = {\n          type: type,\n          string: string\n        };\n\n        switch (type) {\n          case 'symbol':\n          case 'colon':\n            if (buffer2.stringOpen) {\n              if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n              break;\n            }\n\n            switch (string) {\n              case '[':\n              case '{':\n                buffer2.brackets.push(string);\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ']':\n              case '}':\n                buffer2.brackets.pop();\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ',':\n                if (tokenFollowed().type === 'colon') break;\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              case ':':\n                normalToken.type = 'colon';\n                buffer2.isValue = true;\n                break;\n            }\n\n            break;\n\n          case 'delimiter':\n            if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n\n            if (!buffer2.stringOpen) {\n              buffer2.stringOpen = string;\n              break;\n            }\n\n            if (i > 0) {\n              const previousToken = buffer.tokens_fallback[i - 1],\n                    _string = previousToken.string,\n                    _type = previousToken.type,\n                    _char = _string.charAt(_string.length - 1);\n\n              if (_type === 'string' && _char === '\\\\') break;\n            }\n\n            if (buffer2.stringOpen === string) {\n              buffer2.stringOpen = false;\n              break;\n            }\n\n            break;\n\n          case 'primitive':\n          case 'string':\n            if (['false', 'true', 'null', 'undefined'].indexOf(string) > -1) {\n              const lastIndex = buffer.tokens_normalize.length - 1;\n\n              if (lastIndex >= 0) {\n                if (buffer.tokens_normalize[lastIndex].type !== 'string') {\n                  normalToken.type = 'primitive';\n                  break;\n                }\n\n                normalToken.type = 'string';\n                break;\n              }\n\n              normalToken.type = 'primitive';\n              break;\n            }\n\n            if (string === '\\n') if (!buffer2.stringOpen) {\n              normalToken.type = 'linebreak';\n              break;\n            }\n            if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          case 'space':\n            if (buffer2.stringOpen) if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          case 'number':\n            if (buffer2.stringOpen) if (buffer2.isValue) normalToken.type = 'string';else normalToken.type = 'key';\n            break;\n\n          default:\n            break;\n        }\n\n        buffer.tokens_normalize.push(normalToken);\n      }\n\n      for (var i = 0; i < buffer.tokens_normalize.length; i++) {\n        const token = buffer.tokens_normalize[i];\n        let mergedToken = {\n          string: token.string,\n          type: token.type,\n          tokens: [i]\n        };\n        if (['symbol', 'colon'].indexOf(token.type) === -1) if (i + 1 < buffer.tokens_normalize.length) {\n          let count = 0;\n\n          for (var u = i + 1; u < buffer.tokens_normalize.length; u++) {\n            const nextToken = buffer.tokens_normalize[u];\n            if (token.type !== nextToken.type) break;\n            mergedToken.string += nextToken.string;\n            mergedToken.tokens.push(u);\n            count++;\n          }\n\n          i += count;\n        }\n        buffer.tokens_merge.push(mergedToken);\n      }\n\n      const quotes = '\\'\"',\n            alphanumeric = 'abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '0123456789' + '_$';\n      var error = false,\n          line = buffer.tokens_merge.length > 0 ? 1 : 0;\n      buffer2 = {\n        brackets: [],\n        stringOpen: false,\n        isValue: false\n      };\n\n      function setError(tokenID, reason, offset = 0) {\n        error = {\n          token: tokenID,\n          line: line,\n          reason: reason\n        };\n        buffer.tokens_merge[tokenID + offset].type = 'error';\n      }\n\n      function followedBySymbol(tokenID, options) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (options === undefined) console.error('options argument must be an array.');\n        if (tokenID === buffer.tokens_merge.length - 1) return false;\n\n        for (var i = tokenID + 1; i < buffer.tokens_merge.length; i++) {\n          const nextToken = buffer.tokens_merge[i];\n\n          switch (nextToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            case 'symbol':\n            case 'colon':\n              if (options.indexOf(nextToken.string) > -1) return i;else return false;\n              break;\n\n            default:\n              return false;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      function followsSymbol(tokenID, options) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (options === undefined) console.error('options argument must be an array.');\n        if (tokenID === 0) return false;\n\n        for (var i = tokenID - 1; i >= 0; i--) {\n          const previousToken = buffer.tokens_merge[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            case 'symbol':\n            case 'colon':\n              if (options.indexOf(previousToken.string) > -1) return true;\n              return false;\n              break;\n\n            default:\n              return false;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      function typeFollowed(tokenID) {\n        if (tokenID === undefined) console.error('tokenID argument must be an integer.');\n        if (tokenID === 0) return false;\n\n        for (var i = tokenID - 1; i >= 0; i--) {\n          const previousToken = buffer.tokens_merge[i];\n\n          switch (previousToken.type) {\n            case 'space':\n            case 'linebreak':\n              break;\n\n            default:\n              return previousToken.type;\n              break;\n          }\n        }\n\n        return false;\n      }\n\n      let bracketList = [];\n\n      for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        if (error) break;\n        let token = buffer.tokens_merge[i],\n            string = token.string,\n            type = token.type,\n            found = false;\n\n        switch (type) {\n          case 'space':\n            break;\n\n          case 'linebreak':\n            line++;\n            break;\n\n          case 'symbol':\n            switch (string) {\n              case '{':\n              case '[':\n                found = followsSymbol(i, ['}', ']']);\n\n                if (found) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: buffer.tokens_merge[found].string,\n                    secondToken: string\n                  }));\n                  break;\n                }\n\n                if (string === '[' && i > 0) if (!followsSymbol(i, [':', '[', ','])) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.permitted, {\n                    firstToken: \"[\",\n                    secondToken: [\":\", \"[\", \",\"]\n                  }));\n                  break;\n                }\n                if (string === '{') if (followsSymbol(i, ['{'])) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.double, {\n                    token: \"{\"\n                  }));\n                  break;\n                }\n                buffer2.brackets.push(string);\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                bracketList.push({\n                  i: i,\n                  line: line,\n                  string: string\n                });\n                break;\n\n              case '}':\n              case ']':\n                if (string === '}') if (buffer2.brackets[buffer2.brackets.length - 1] !== '{') {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.brace.curly.missingOpen));\n                  break;\n                }\n                if (string === '}') if (followsSymbol(i, [','])) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \",\",\n                    secondToken: \"}\"\n                  }));\n                  break;\n                }\n                if (string === ']') if (buffer2.brackets[buffer2.brackets.length - 1] !== '[') {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.brace.square.missingOpen));\n                  break;\n                }\n                if (string === ']') if (followsSymbol(i, [':'])) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \":\",\n                    secondToken: \"]\"\n                  }));\n                  break;\n                }\n                buffer2.brackets.pop();\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                bracketList.push({\n                  i: i,\n                  line: line,\n                  string: string\n                });\n                break;\n\n              case ',':\n                found = followsSymbol(i, ['{']);\n\n                if (found) {\n                  if (followedBySymbol(i, ['}'])) {\n                    setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.brace.curly.cannotWrap, {\n                      token: \",\"\n                    }));\n                    break;\n                  }\n\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                    firstToken: \"{\",\n                    secondToken: \",\"\n                  }));\n                  break;\n                }\n\n                if (followedBySymbol(i, ['}', ',', ']'])) {\n                  setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.noTrailingOrLeadingComma));\n                  break;\n                }\n\n                found = typeFollowed(i);\n\n                switch (found) {\n                  case 'key':\n                  case 'colon':\n                    setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.termSequence.prohibited, {\n                      firstTerm: found === 'key' ? locale.types.key : locale.symbols.colon,\n                      secondTerm: locale.symbols.comma\n                    }));\n                    break;\n\n                  case 'symbol':\n                    if (followsSymbol(i, ['{'])) {\n                      setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                        firstToken: \"{\",\n                        secondToken: \",\"\n                      }));\n                      break;\n                    }\n\n                    break;\n\n                  default:\n                    break;\n                }\n\n                buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n                break;\n\n              default:\n                break;\n            }\n\n            buffer.json += string;\n            break;\n\n          case 'colon':\n            found = followsSymbol(i, ['[']);\n\n            if (found && followedBySymbol(i, [']'])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.brace.square.cannotWrap, {\n                token: \":\"\n              }));\n              break;\n            }\n\n            if (found) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.prohibited, {\n                firstToken: \"[\",\n                secondToken: \":\"\n              }));\n              break;\n            }\n\n            if (typeFollowed(i) !== 'key') {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.symbols.colon,\n                secondTerm: locale.types.key\n              }));\n              break;\n            }\n\n            if (followedBySymbol(i, ['}', ']'])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.symbols.colon,\n                secondTerm: locale.types.value\n              }));\n              break;\n            }\n\n            buffer2.isValue = true;\n            buffer.json += string;\n            break;\n\n          case 'key':\n          case 'string':\n            let firstChar = string.charAt(0),\n                lastChar = string.charAt(string.length - 1),\n                quote_primary = quotes.indexOf(firstChar);\n            if (quotes.indexOf(firstChar) === -1) if (quotes.indexOf(lastChar) !== -1) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.missingOpen, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if (quotes.indexOf(lastChar) === -1) if (quotes.indexOf(firstChar) !== -1) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.missingClose, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if (quotes.indexOf(firstChar) > -1) if (firstChar !== lastChar) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.missingClose, {\n                quote: firstChar\n              }));\n              break;\n            }\n            if ('string' === type) if (quotes.indexOf(firstChar) === -1 && quotes.indexOf(lastChar) === -1) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.mustBeWrappedByQuotes));\n              break;\n            }\n            if ('key' === type) if (followedBySymbol(i, ['}', ']'])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.termSequence.permitted, {\n                firstTerm: locale.types.key,\n                secondTerm: locale.symbols.colon\n              }));\n            }\n            if (quotes.indexOf(firstChar) === -1 && quotes.indexOf(lastChar) === -1) for (var h = 0; h < string.length; h++) {\n              if (error) break;\n              const c = string.charAt(h);\n\n              if (alphanumeric.indexOf(c) === -1) {\n                setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.nonAlphanumeric, {\n                  token: c\n                }));\n                break;\n              }\n            }\n            if (firstChar === \"'\") string = '\"' + string.slice(1, -1) + '\"';else if (firstChar !== '\"') string = '\"' + string + '\"';\n            if ('key' === type) if ('key' === typeFollowed(i)) {\n              if (i > 0) if (!isNaN(buffer.tokens_merge[i - 1])) {\n                buffer.tokens_merge[i - 1] += buffer.tokens_merge[i];\n                setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.key.numberAndLetterMissingQuotes));\n                break;\n              }\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.key.spaceMissingQuotes));\n              break;\n            }\n            if ('key' === type) if (!followsSymbol(i, ['{', ','])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"{\", \",\"]\n              }));\n              break;\n            }\n            if ('string' === type) if (!followsSymbol(i, ['[', ':', ','])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"[\", \":\", \",\"]\n              }));\n              break;\n            }\n            if ('key' === type) if (buffer2.isValue) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.string.unexpectedKey));\n              break;\n            }\n            if ('string' === type) if (!buffer2.isValue) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.key.unexpectedString));\n              break;\n            }\n            buffer.json += string;\n            break;\n\n          case 'number':\n          case 'primitive':\n            if (followsSymbol(i, ['{'])) {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n              string = '\"' + string + '\"';\n            } else if (typeFollowed(i) === 'key') {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n            } else if (!followsSymbol(i, ['[', ':', ','])) {\n              setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.tokenSequence.permitted, {\n                firstToken: type,\n                secondToken: [\"[\", \":\", \",\"]\n              }));\n              break;\n            }\n\n            if (type !== 'key') if (!buffer2.isValue) {\n              buffer.tokens_merge[i].type = 'key';\n              type = buffer.tokens_merge[i].type;\n              string = '\"' + string + '\"';\n            }\n            if (type === 'primitive') if (string === 'undefined') setError(i, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.useInstead, {\n              badToken: \"undefined\",\n              goodToken: \"null\"\n            }));\n            buffer.json += string;\n            break;\n        }\n      }\n\n      let noEscapedSingleQuote = '';\n\n      for (var i = 0; i < buffer.json.length; i++) {\n        let current = buffer.json.charAt(i),\n            next = '';\n\n        if (i + 1 < buffer.json.length) {\n          next = buffer.json.charAt(i + 1);\n\n          if (current === '\\\\' && next === \"'\") {\n            noEscapedSingleQuote += next;\n            i++;\n            continue;\n          }\n        }\n\n        noEscapedSingleQuote += current;\n      }\n\n      buffer.json = noEscapedSingleQuote;\n\n      if (!error) {\n        const maxIterations = Math.ceil(bracketList.length / 2);\n        let round = 0,\n            delta = false;\n\n        function removePair(index) {\n          bracketList.splice(index + 1, 1);\n          bracketList.splice(index, 1);\n          if (!delta) delta = true;\n        }\n\n        while (bracketList.length > 0) {\n          delta = false;\n\n          for (var tokenCount = 0; tokenCount < bracketList.length - 1; tokenCount++) {\n            const pair = bracketList[tokenCount].string + bracketList[tokenCount + 1].string;\n            if (['[]', '{}'].indexOf(pair) > -1) removePair(tokenCount);\n          }\n\n          round++;\n          if (!delta) break;\n          if (round >= maxIterations) break;\n        }\n\n        if (bracketList.length > 0) {\n          const _tokenString = bracketList[0].string,\n                _tokenPosition = bracketList[0].i,\n                _closingBracketType = _tokenString === '[' ? ']' : '}';\n\n          line = bracketList[0].line;\n          setError(_tokenPosition, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.brace[_closingBracketType === ']' ? 'square' : 'curly'].missingClose));\n        }\n      }\n\n      if (!error) if ([undefined, ''].indexOf(buffer.json) === -1) try {\n        buffer.jsObject = JSON.parse(buffer.json);\n      } catch (err) {\n        const errorMessage = err.message,\n              subsMark = errorMessage.indexOf('position');\n        if (subsMark === -1) throw new Error('Error parsing failed');\n        const errPositionStr = errorMessage.substring(subsMark + 9, errorMessage.length),\n              errPosition = parseInt(errPositionStr);\n        let charTotal = 0,\n            tokenIndex = 0,\n            token = false,\n            _line = 1,\n            exitWhile = false;\n\n        while (charTotal < errPosition && !exitWhile) {\n          token = buffer.tokens_merge[tokenIndex];\n          if ('linebreak' === token.type) _line++;\n          if (['space', 'linebreak'].indexOf(token.type) === -1) charTotal += token.string.length;\n          if (charTotal >= errPosition) break;\n          tokenIndex++;\n          if (!buffer.tokens_merge[tokenIndex + 1]) exitWhile = true;\n        }\n\n        line = _line;\n        let backslashCount = 0;\n\n        for (let i = 0; i < token.string.length; i++) {\n          const char = token.string.charAt(i);\n          if (char === '\\\\') backslashCount = backslashCount > 0 ? backslashCount + 1 : 1;else {\n            if (backslashCount % 2 !== 0 || backslashCount === 0) if ('\\'\"bfnrt'.indexOf(char) === -1) {\n              setError(tokenIndex, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.unexpected, {\n                token: '\\\\'\n              }));\n            }\n            backslashCount = 0;\n          }\n        }\n\n        if (!error) setError(tokenIndex, (0,_locale__WEBPACK_IMPORTED_MODULE_4__.format)(locale.invalidToken.unexpected, {\n          token: token.string\n        }));\n      }\n      let _line = 1,\n          _depth = 0;\n\n      function newIndent() {\n        var space = [];\n\n        for (var i = 0; i < _depth * 2; i++) space.push('&nbsp;');\n\n        return space.join('');\n      }\n\n      function newLineBreak(byPass = false) {\n        _line++;\n\n        if (_depth > 0 || byPass) {\n          return '<br>';\n        }\n\n        return '';\n      }\n\n      function newLineBreakAndIndent(byPass = false) {\n        return newLineBreak(byPass) + newIndent();\n      }\n\n      ;\n      if (!error) for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        const token = buffer.tokens_merge[i],\n              string = token.string,\n              type = token.type;\n\n        switch (type) {\n          case 'space':\n          case 'linebreak':\n            break;\n\n          case 'string':\n          case 'number':\n          case 'primitive':\n          case 'error':\n            buffer.markup += (followsSymbol(i, [',', '[']) ? newLineBreakAndIndent() : '') + newSpan(i, token, _depth);\n            break;\n\n          case 'key':\n            buffer.markup += newLineBreakAndIndent() + newSpan(i, token, _depth);\n            break;\n\n          case 'colon':\n            buffer.markup += newSpan(i, token, _depth) + '&nbsp;';\n            break;\n\n          case 'symbol':\n            switch (string) {\n              case '[':\n              case '{':\n                buffer.markup += (!followsSymbol(i, [':']) ? newLineBreakAndIndent() : '') + newSpan(i, token, _depth);\n                _depth++;\n                break;\n\n              case ']':\n              case '}':\n                _depth--;\n\n                const islastToken = i === buffer.tokens_merge.length - 1,\n                      _adjustment = i > 0 ? ['[', '{'].indexOf(buffer.tokens_merge[i - 1].string) > -1 ? '' : newLineBreakAndIndent(islastToken) : '';\n\n                buffer.markup += _adjustment + newSpan(i, token, _depth);\n                break;\n\n              case ',':\n                buffer.markup += newSpan(i, token, _depth);\n                break;\n            }\n\n            break;\n        }\n      }\n\n      if (error) {\n        let _line_fallback = 1;\n\n        function countCarrigeReturn(string) {\n          let count = 0;\n\n          for (var i = 0; i < string.length; i++) {\n            if (['\\n', '\\r'].indexOf(string[i]) > -1) count++;\n          }\n\n          return count;\n        }\n\n        _line = 1;\n\n        for (var i = 0; i < buffer.tokens_merge.length; i++) {\n          const token = buffer.tokens_merge[i],\n                type = token.type,\n                string = token.string;\n          if (type === 'linebreak') _line++;\n          buffer.markup += newSpan(i, token, _depth);\n          _line_fallback += countCarrigeReturn(string);\n        }\n\n        _line++;\n        _line_fallback++;\n        if (_line < _line_fallback) _line = _line_fallback;\n      }\n\n      for (var i = 0; i < buffer.tokens_merge.length; i++) {\n        let token = buffer.tokens_merge[i];\n        buffer.indented += token.string;\n        if (['space', 'linebreak'].indexOf(token.type) === -1) buffer.tokens_plainText += token.string;\n      }\n\n      if (error) {\n        function isFunction(functionToCheck) {\n          return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n        }\n\n        if ('modifyErrorText' in this.props) if (isFunction(this.props.modifyErrorText)) error.reason = this.props.modifyErrorText(error.reason);\n      }\n\n      return {\n        tokens: buffer.tokens_merge,\n        noSpaces: buffer.tokens_plainText,\n        indented: buffer.indented,\n        json: buffer.json,\n        jsObject: buffer.jsObject,\n        markup: buffer.markup,\n        lines: _line,\n        error: error\n      };\n    }\n\n    ;\n    /**\r\n     *     JS OBJECTS || PLACEHOLDER\r\n     */\n\n    if (!('nodeType' in something)) {\n      let buffer = {\n        inputText: JSON.stringify(something),\n        position: 0,\n        currentChar: '',\n        tokenPrimary: '',\n        tokenSecondary: '',\n        brackets: [],\n        isValue: false,\n        stringOpen: false,\n        stringStart: 0,\n        tokens: []\n      };\n\n      function escape_character() {\n        if (buffer.currentChar !== '\\\\') return false;\n        return true;\n      }\n\n      function extract(string, position) {\n        return string.slice(0, position) + string.slice(position + 1);\n      }\n\n      function determine_string() {\n        if ('\\'\"'.indexOf(buffer.currentChar) === -1) return false;\n\n        if (!buffer.stringOpen) {\n          add_tokenSecondary();\n          buffer.stringStart = buffer.position;\n          buffer.stringOpen = buffer.currentChar;\n          return true;\n        }\n\n        if (buffer.stringOpen === buffer.currentChar) {\n          add_tokenSecondary();\n          const stringToken = buffer.inputText.substring(buffer.stringStart, buffer.position + 1);\n          add_tokenPrimary(stringToken);\n          buffer.stringOpen = false;\n          return true;\n        }\n\n        return false;\n      }\n\n      function determine_value() {\n        if (':,{}[]'.indexOf(buffer.currentChar) === -1) return false;\n        if (buffer.stringOpen) return false;\n        add_tokenSecondary();\n        add_tokenPrimary(buffer.currentChar);\n\n        switch (buffer.currentChar) {\n          case ':':\n            buffer.isValue = true;\n            return true;\n            break;\n\n          case '{':\n          case '[':\n            buffer.brackets.push(buffer.currentChar);\n            break;\n\n          case '}':\n          case ']':\n            buffer.brackets.pop();\n            break;\n        }\n\n        if (buffer.currentChar !== ':') buffer.isValue = buffer.brackets[buffer.brackets.length - 1] === '[';\n        return true;\n      }\n\n      function add_tokenSecondary() {\n        if (buffer.tokenSecondary.length === 0) return false;\n        buffer.tokens.push(buffer.tokenSecondary);\n        buffer.tokenSecondary = '';\n        return true;\n      }\n\n      function add_tokenPrimary(value) {\n        if (value.length === 0) return false;\n        buffer.tokens.push(value);\n        return true;\n      }\n\n      for (var i = 0; i < buffer.inputText.length; i++) {\n        buffer.position = i;\n        buffer.currentChar = buffer.inputText.charAt(buffer.position);\n        const a = determine_value(),\n              b = determine_string(),\n              c = escape_character();\n        if (!a && !b && !c) if (!buffer.stringOpen) buffer.tokenSecondary += buffer.currentChar;\n      }\n\n      let buffer2 = {\n        brackets: [],\n        isValue: false,\n        tokens: []\n      };\n      buffer2.tokens = buffer.tokens.map(token => {\n        let type = '',\n            string = '',\n            value = '';\n\n        switch (token) {\n          case ',':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case ':':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.isValue = true;\n            break;\n\n          case '{':\n          case '[':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.brackets.push(token);\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case '}':\n          case ']':\n            type = 'symbol';\n            string = token;\n            value = token;\n            buffer2.brackets.pop();\n            buffer2.isValue = buffer2.brackets[buffer2.brackets.length - 1] === '[';\n            break;\n\n          case 'undefined':\n            type = 'primitive';\n            string = token;\n            value = undefined;\n            break;\n\n          case 'null':\n            type = 'primitive';\n            string = token;\n            value = null;\n            break;\n\n          case 'false':\n            type = 'primitive';\n            string = token;\n            value = false;\n            break;\n\n          case 'true':\n            type = 'primitive';\n            string = token;\n            value = true;\n            break;\n\n          default:\n            const C = token.charAt(0);\n\n            function stripQuotesFromKey(text) {\n              if (text.length === 0) return text;\n              if (['\"\"', \"''\"].indexOf(text) > -1) return \"''\";\n              let wrappedInQuotes = false;\n\n              for (var i = 0; i < 2; i++) {\n                if ([text.charAt(0), text.charAt(text.length - 1)].indexOf(['\"', \"'\"][i]) > -1) {\n                  wrappedInQuotes = true;\n                  break;\n                }\n              }\n\n              if (wrappedInQuotes && text.length >= 2) text = text.slice(1, -1);\n\n              const nonAlphaNumeric = text.replace(/\\w/g, ''),\n                    alphaNumeric = text.replace(/\\W+/g, ''),\n                    mayRemoveQuotes = ((nonAlphaNumeric, text) => {\n                let numberAndLetter = false;\n\n                for (var i = 0; i < text.length; i++) {\n                  if (i === 0) if (isNaN(text.charAt(i))) break;\n\n                  if (isNaN(text.charAt(i))) {\n                    numberAndLetter = true;\n                    break;\n                  }\n                }\n\n                return !(nonAlphaNumeric.length > 0 || numberAndLetter);\n              })(nonAlphaNumeric, text),\n                    hasQuotes = (string => {\n                for (var i = 0; i < string.length; i++) {\n                  if ([\"'\", '\"'].indexOf(string.charAt(i)) > -1) return true;\n                }\n\n                return false;\n              })(nonAlphaNumeric);\n\n              if (hasQuotes) {\n                let newText = '';\n                const charList = text.split('');\n\n                for (var ii = 0; ii < charList.length; ii++) {\n                  let char = charList[ii];\n                  if ([\"'\", '\"'].indexOf(char) > -1) char = '\\\\' + char;\n                  newText += char;\n                }\n\n                text = newText;\n              }\n\n              if (!mayRemoveQuotes) return \"'\" + text + \"'\";else return text;\n            }\n\n            if ('\\'\"'.indexOf(C) > -1) {\n              if (buffer2.isValue) type = 'string';else type = 'key';\n              if (type === 'key') string = stripQuotesFromKey(token);\n\n              if (type === 'string') {\n                string = '';\n                const charList2 = token.slice(1, -1).split('');\n\n                for (var ii = 0; ii < charList2.length; ii++) {\n                  let char = charList2[ii];\n                  if ('\\'\\\"'.indexOf(char) > -1) char = '\\\\' + char;\n                  string += char;\n                }\n\n                string = \"'\" + string + \"'\";\n              }\n\n              value = string;\n              break;\n            }\n\n            if (!isNaN(token)) {\n              type = 'number';\n              string = token;\n              value = Number(token);\n              break;\n            }\n\n            if (token.length > 0) if (!buffer2.isValue) {\n              type = 'key';\n              string = token;\n              if (string.indexOf(' ') > -1) string = \"'\" + string + \"'\";\n              value = string;\n              break;\n            }\n        }\n\n        return {\n          type: type,\n          string: string,\n          value: value,\n          depth: buffer2.brackets.length\n        };\n      });\n      let clean = '';\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n        clean += token.string;\n      }\n\n      function indent(number) {\n        var space = [];\n\n        for (var i = 0; i < number * 2; i++) space.push(' ');\n\n        return (number > 0 ? '\\n' : '') + space.join('');\n      }\n\n      ;\n      let indentation = '';\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n\n        switch (token.string) {\n          case '[':\n          case '{':\n            const nextToken = i < buffer2.tokens.length - 1 - 1 ? buffer2.tokens[i + 1] : '';\n            if ('}]'.indexOf(nextToken.string) === -1) indentation += token.string + indent(token.depth);else indentation += token.string;\n            break;\n\n          case ']':\n          case '}':\n            const prevToken = i > 0 ? buffer2.tokens[i - 1] : '';\n            if ('[{'.indexOf(prevToken.string) === -1) indentation += indent(token.depth) + token.string;else indentation += token.string;\n            break;\n\n          case ':':\n            indentation += token.string + ' ';\n            break;\n\n          case ',':\n            indentation += token.string + indent(token.depth);\n            break;\n\n          default:\n            indentation += token.string;\n            break;\n        }\n      }\n\n      let lines = 1;\n\n      function indentII(number) {\n        var space = [];\n        if (number > 0) lines++;\n\n        for (var i = 0; i < number * 2; i++) space.push('&nbsp;');\n\n        return (number > 0 ? '<br>' : '') + space.join('');\n      }\n\n      ;\n      let markup = '';\n      const lastIndex = buffer2.tokens.length - 1;\n\n      for (var i = 0; i < buffer2.tokens.length; i++) {\n        let token = buffer2.tokens[i];\n        let span = newSpan(i, token, token.depth);\n\n        switch (token.string) {\n          case '{':\n          case '[':\n            const nextToken = i < buffer2.tokens.length - 1 - 1 ? buffer2.tokens[i + 1] : '';\n            if ('}]'.indexOf(nextToken.string) === -1) markup += span + indentII(token.depth);else markup += span;\n            break;\n\n          case '}':\n          case ']':\n            const prevToken = i > 0 ? buffer2.tokens[i - 1] : '';\n            if ('[{'.indexOf(prevToken.string) === -1) markup += indentII(token.depth) + (lastIndex === i ? '<br>' : '') + span;else markup += span;\n            break;\n\n          case ':':\n            markup += span + ' ';\n            break;\n\n          case ',':\n            markup += span + indentII(token.depth);\n            break;\n\n          default:\n            markup += span;\n            break;\n        }\n      }\n\n      lines += 2;\n      return {\n        tokens: buffer2.tokens,\n        noSpaces: clean,\n        indented: indentation,\n        json: JSON.stringify(something),\n        jsObject: something,\n        markup: markup,\n        lines: lines\n      };\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSONInput);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQzNCO0FBQ1g7QUFDbUI7QUFDekI7QUFDVTtBQUNNOztBQUV4Qyx3QkFBd0IsNENBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGdCQUFnQiwrQ0FBTTtBQUN0QixpR0FBaUcsK0NBQU0sVUFBVSwrQ0FBTTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0Usa0ZBQWtGO0FBQ2xGLHFGQUFxRjtBQUNyRiwyRkFBMkY7QUFDM0YsbUVBQW1FO0FBQ25FLHdGQUF3RjtBQUN4Rix5RUFBeUU7QUFDekU7QUFDQSxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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c0Y7QUFDekc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCLHVCQUF1Qjs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsNEVBQTRFO0FBQzlGOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUJBQW1CLDZHQUE2RztBQUNoSTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtEQUFlLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWpzb24tZWRpdG9yLWFqcm0vZXMvaW5kZXguanM/N2YzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgcmVhY3QtanNvbi1lZGl0b3ItYWpybSB2Mi41LjE0XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWRcIjtcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdGhlbWVzIGZyb20gJy4vdGhlbWVzJztcbmltcG9ydCB7IGlkZW50aWNhbCwgZ2V0VHlwZSB9IGZyb20gJy4vbWl0c3VrZXRhJztcbmltcG9ydCBlcnIgZnJvbSAnLi9lcnInO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnLi9sb2NhbGUnO1xuaW1wb3J0IGRlZmF1bHRMb2NhbGUgZnJvbSAnLi9sb2NhbGUvZW4nO1xuXG5jbGFzcyBKU09OSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnVwZGF0ZUludGVybmFsUHJvcHMgPSB0aGlzLnVwZGF0ZUludGVybmFsUHJvcHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZU1hcmt1cCA9IHRoaXMuY3JlYXRlTWFya3VwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkJsdXIgPSB0aGlzLm9uQmx1ci5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0Q3Vyc29yUG9zaXRpb24gPSB0aGlzLnNldEN1cnNvclBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zY2hlZHVsZWRVcGRhdGUgPSB0aGlzLnNjaGVkdWxlZFVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0VXBkYXRlVGltZSA9IHRoaXMuc2V0VXBkYXRlVGltZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyTGFiZWxzID0gdGhpcy5yZW5kZXJMYWJlbHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm5ld1NwYW4gPSB0aGlzLm5ld1NwYW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlckVycm9yTWVzc2FnZSA9IHRoaXMucmVuZGVyRXJyb3JNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNob3dQbGFjZWhvbGRlciA9IHRoaXMuc2hvd1BsYWNlaG9sZGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy50b2tlbml6ZSA9IHRoaXMudG9rZW5pemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uS2V5UHJlc3MgPSB0aGlzLm9uS2V5UHJlc3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uS2V5RG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBhc3RlID0gdGhpcy5vblBhc3RlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wRXZlbnQgPSB0aGlzLnN0b3BFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmQ29udGVudCA9IG51bGw7XG4gICAgdGhpcy5yZWZMYWJlbHMgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlSW50ZXJuYWxQcm9wcygpO1xuICAgIHRoaXMucmVuZGVyQ291bnQgPSAxO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBwcmV2UGxhY2Vob2xkZXI6ICcnLFxuICAgICAgbWFya3VwVGV4dDogJycsXG4gICAgICBwbGFpblRleHQ6ICcnLFxuICAgICAganNvbjogJycsXG4gICAgICBqc09iamVjdDogdW5kZWZpbmVkLFxuICAgICAgbGluZXM6IGZhbHNlLFxuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5wcm9wcy5sb2NhbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltyZWFjdC1qc29uLWVkaXRvci1hanJtIC0gRGVwcmVjYXRpb24gV2FybmluZ10gWW91IGRpZCBub3QgcHJvdmlkZSBhICdsb2NhbGUnIHByb3AgZm9yIHlvdXIgSlNPTiBpbnB1dCAtIFRoaXMgd2lsbCBiZSByZXF1aXJlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBFbmdsaXNoIGhhcyBiZWVuIHNldCBhcyBhIGRlZmF1bHQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUludGVybmFsUHJvcHMoKSB7XG4gICAgbGV0IGNvbG9ycyA9IHt9LFxuICAgICAgICBzdHlsZSA9IHt9LFxuICAgICAgICB0aGVtZSA9IHRoZW1lcy5kYXJrX3ZzY29kZV90cmlidXRlO1xuICAgIGlmICgndGhlbWUnIGluIHRoaXMucHJvcHMpIGlmICh0eXBlb2YgdGhpcy5wcm9wcy50aGVtZSA9PT0gJ3N0cmluZycpIGlmICh0aGlzLnByb3BzLnRoZW1lIGluIHRoZW1lcykgdGhlbWUgPSB0aGVtZXNbdGhpcy5wcm9wcy50aGVtZV07XG4gICAgY29sb3JzID0gdGhlbWU7XG4gICAgaWYgKCdjb2xvcnMnIGluIHRoaXMucHJvcHMpIGNvbG9ycyA9IHtcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0JyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmRlZmF1bHQgOiBjb2xvcnMuZGVmYXVsdCxcbiAgICAgIHN0cmluZzogJ3N0cmluZycgaW4gdGhpcy5wcm9wcy5jb2xvcnMgPyB0aGlzLnByb3BzLmNvbG9ycy5zdHJpbmcgOiBjb2xvcnMuc3RyaW5nLFxuICAgICAgbnVtYmVyOiAnbnVtYmVyJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLm51bWJlciA6IGNvbG9ycy5udW1iZXIsXG4gICAgICBjb2xvbjogJ2NvbG9uJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmNvbG9uIDogY29sb3JzLmNvbG9uLFxuICAgICAga2V5czogJ2tleXMnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMua2V5cyA6IGNvbG9ycy5rZXlzLFxuICAgICAga2V5c193aGl0ZVNwYWNlOiAna2V5c193aGl0ZVNwYWNlJyBpbiB0aGlzLnByb3BzLmNvbG9ycyA/IHRoaXMucHJvcHMuY29sb3JzLmtleXNfd2hpdGVTcGFjZSA6IGNvbG9ycy5rZXlzX3doaXRlU3BhY2UsXG4gICAgICBwcmltaXRpdmU6ICdwcmltaXRpdmUnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMucHJpbWl0aXZlIDogY29sb3JzLnByaW1pdGl2ZSxcbiAgICAgIGVycm9yOiAnZXJyb3InIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMuZXJyb3IgOiBjb2xvcnMuZXJyb3IsXG4gICAgICBiYWNrZ3JvdW5kOiAnYmFja2dyb3VuZCcgaW4gdGhpcy5wcm9wcy5jb2xvcnMgPyB0aGlzLnByb3BzLmNvbG9ycy5iYWNrZ3JvdW5kIDogY29sb3JzLmJhY2tncm91bmQsXG4gICAgICBiYWNrZ3JvdW5kX3dhcm5pbmc6ICdiYWNrZ3JvdW5kX3dhcm5pbmcnIGluIHRoaXMucHJvcHMuY29sb3JzID8gdGhpcy5wcm9wcy5jb2xvcnMuYmFja2dyb3VuZF93YXJuaW5nIDogY29sb3JzLmJhY2tncm91bmRfd2FybmluZ1xuICAgIH07XG4gICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgaWYgKCdzdHlsZScgaW4gdGhpcy5wcm9wcykgc3R5bGUgPSB7XG4gICAgICBvdXRlckJveDogJ291dGVyQm94JyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS5vdXRlckJveCA6IHt9LFxuICAgICAgY29udGFpbmVyOiAnY29udGFpbmVyJyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS5jb250YWluZXIgOiB7fSxcbiAgICAgIHdhcm5pbmdCb3g6ICd3YXJuaW5nQm94JyBpbiB0aGlzLnByb3BzLnN0eWxlID8gdGhpcy5wcm9wcy5zdHlsZS53YXJuaW5nQm94IDoge30sXG4gICAgICBlcnJvck1lc3NhZ2U6ICdlcnJvck1lc3NhZ2UnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmVycm9yTWVzc2FnZSA6IHt9LFxuICAgICAgYm9keTogJ2JvZHknIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmJvZHkgOiB7fSxcbiAgICAgIGxhYmVsQ29sdW1uOiAnbGFiZWxDb2x1bW4nIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmxhYmVsQ29sdW1uIDoge30sXG4gICAgICBsYWJlbHM6ICdsYWJlbHMnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmxhYmVscyA6IHt9LFxuICAgICAgY29udGVudEJveDogJ2NvbnRlbnRCb3gnIGluIHRoaXMucHJvcHMuc3R5bGUgPyB0aGlzLnByb3BzLnN0eWxlLmNvbnRlbnRCb3ggOiB7fVxuICAgIH07ZWxzZSBzdHlsZSA9IHtcbiAgICAgIG91dGVyQm94OiB7fSxcbiAgICAgIGNvbnRhaW5lcjoge30sXG4gICAgICB3YXJuaW5nQm94OiB7fSxcbiAgICAgIGVycm9yTWVzc2FnZToge30sXG4gICAgICBib2R5OiB7fSxcbiAgICAgIGxhYmVsQ29sdW1uOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBjb250ZW50Qm94OiB7fVxuICAgIH07XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuY29uZmlybUdvb2QgPSAnY29uZmlybUdvb2QnIGluIHRoaXMucHJvcHMgPyB0aGlzLnByb3BzLmNvbmZpcm1Hb29kIDogdHJ1ZTtcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0IHx8ICc2MTBweCcsXG4gICAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMucHJvcHMud2lkdGggfHwgJzQ3OXB4JztcbiAgICB0aGlzLnRvdGFsSGVpZ2h0ID0gdG90YWxIZWlnaHQ7XG4gICAgdGhpcy50b3RhbFdpZHRoID0gdG90YWxXaWR0aDtcblxuICAgIGlmICghKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSB8fCB0aGlzLnByb3BzLm9uS2V5UHJlc3NVcGRhdGUpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuc2NoZWR1bGVkVXBkYXRlLCAxMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRBZnRlcktleVByZXNzID0gJ3dhaXRBZnRlcktleVByZXNzJyBpbiB0aGlzLnByb3BzID8gdGhpcy5wcm9wcy53YWl0QWZ0ZXJLZXlQcmVzcyA6IDEwMDA7XG4gICAgdGhpcy5yZXNldENvbmZpZ3VyYXRpb24gPSAncmVzZXQnIGluIHRoaXMucHJvcHMgPyB0aGlzLnByb3BzLnJlc2V0IDogZmFsc2U7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnByb3BzLmlkLFxuICAgICAgICAgIG1hcmt1cFRleHQgPSB0aGlzLnN0YXRlLm1hcmt1cFRleHQsXG4gICAgICAgICAgZXJyb3IgPSB0aGlzLnByb3BzLmVycm9yIHx8IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgY29sb3JzID0gdGhpcy5jb2xvcnMsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlLFxuICAgICAgICAgIGNvbmZpcm1Hb29kID0gdGhpcy5jb25maXJtR29vZCxcbiAgICAgICAgICB0b3RhbEhlaWdodCA9IHRoaXMudG90YWxIZWlnaHQsXG4gICAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMudG90YWxXaWR0aCxcbiAgICAgICAgICBoYXNFcnJvciA9ICEhdGhpcy5wcm9wcy5lcnJvciB8fCAoZXJyb3IgPyAndG9rZW4nIGluIGVycm9yIDogZmFsc2UpO1xuICAgIHRoaXMucmVuZGVyQ291bnQrKztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBuYW1lOiBcIm91dGVyLWJveFwiLFxuICAgICAgaWQ6IGlkICYmIGlkICsgJy1vdXRlci1ib3gnLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ25vbmUnLFxuICAgICAgICBoZWlnaHQ6IHRvdGFsSGVpZ2h0LFxuICAgICAgICB3aWR0aDogdG90YWxXaWR0aCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0sIHN0eWxlLm91dGVyQm94KVxuICAgIH0sIGNvbmZpcm1Hb29kID8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBvcGFjaXR5OiBoYXNFcnJvciA/IDAgOiAxLFxuICAgICAgICBoZWlnaHQ6ICczMHB4JyxcbiAgICAgICAgd2lkdGg6ICczMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtMjUlLDI1JSknLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogJzAuMnMnLFxuICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246ICdjdWJpYy1iZXppZXIoMCwgMSwgMC41LCAxKSdcbiAgICAgIH1cbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIGhlaWdodDogXCIzMHB4XCIsXG4gICAgICB3aWR0aDogXCIzMHB4XCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAxMDAgMTAwXCJcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBmaWxsOiBcImdyZWVuXCIsXG4gICAgICBvcGFjaXR5OiBcIjAuODVcIixcbiAgICAgIGQ6IFwiTTM5LjM2Myw3OUwxNiw1NS40OWwxMS4zNDctMTEuNDE5TDM5LjY5NCw1Ni40OUw3Mi45ODMsMjNMODQsMzQuMDg1TDM5LjM2Myw3OXpcIlxuICAgIH0pKSkgOiB2b2lkIDAsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgbmFtZTogXCJjb250YWluZXJcIixcbiAgICAgIGlkOiBpZCAmJiBpZCArICctY29udGFpbmVyJyxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgaGVpZ2h0OiB0b3RhbEhlaWdodCxcbiAgICAgICAgd2lkdGg6IHRvdGFsV2lkdGgsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgZm9udEZhbWlseTogJ1JvYm90bywgc2Fucy1zZXJpZidcbiAgICAgIH0sIHN0eWxlLmNvbnRhaW5lciksXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIG5hbWU6IFwid2FybmluZy1ib3hcIixcbiAgICAgIGlkOiBpZCAmJiBpZCArICctd2FybmluZy1ib3gnLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGhlaWdodDogaGFzRXJyb3IgPyAnNjBweCcgOiAnMHB4JyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5iYWNrZ3JvdW5kX3dhcm5pbmcsXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogJzAuMnMnLFxuICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246ICdjdWJpYy1iZXppZXIoMCwgMSwgMC41LCAxKSdcbiAgICAgIH0sIHN0eWxlLndhcm5pbmdCb3gpLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICB3aWR0aDogJzYwcHgnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICB3aWR0aDogJzYwcHgnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIGhlaWdodDogXCIyNXB4XCIsXG4gICAgICB3aWR0aDogXCIyNXB4XCIsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAxMDAgMTAwXCJcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBmaWxsOiBcInJlZFwiLFxuICAgICAgZDogXCJNNzMuOSw1Ljc1YzAuNDY3LTAuNDY3LDEuMDY3LTAuNywxLjgtMC43YzAuNywwLDEuMjgzLDAuMjMzLDEuNzUsMC43bDE2LjgsMTYuOCAgYzAuNDY3LDAuNSwwLjcsMS4wODQsMC43LDEuNzVjMCwwLjczMy0wLjIzMywxLjMzNC0wLjcsMS44MDFMNzAuMzUsNTBsMjMuOSwyMy45NWMwLjUsMC40NjcsMC43NSwxLjA2NiwwLjc1LDEuOCAgYzAsMC42NjctMC4yNSwxLjI1LTAuNzUsMS43NWwtMTYuOCwxNi43NWMtMC41MzQsMC40NjctMS4xMTcsMC43LTEuNzUsMC43cy0xLjIzMy0wLjIzMy0xLjgtMC43TDUwLDcwLjM1MUwyNi4xLDk0LjI1ICBjLTAuNTY3LDAuNDY3LTEuMTY3LDAuNy0xLjgsMC43Yy0wLjY2NywwLTEuMjgzLTAuMjMzLTEuODUtMC43TDUuNzUsNzcuNUM1LjI1LDc3LDUsNzYuNDE3LDUsNzUuNzVjMC0wLjczMywwLjI1LTEuMzMzLDAuNzUtMS44ICBMMjkuNjUsNTBMNS43NSwyNi4xMDFDNS4yNSwyNS42NjcsNSwyNS4wNjYsNSwyNC4zYzAtMC42NjYsMC4yNS0xLjI1LDAuNzUtMS43NWwxNi44LTE2LjhjMC40NjctMC40NjcsMS4wNS0wLjcsMS43NS0wLjcgIGMwLjczMywwLDEuMzMzLDAuMjMzLDEuOCwwLjdMNTAsMjkuNjVMNzMuOSw1Ljc1elwiXG4gICAgfSkpKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgaGVpZ2h0OiAnNjBweCcsXG4gICAgICAgIHdpZHRoOiAnY2FsYygxMDAlIC0gNjBweCknLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2tcbiAgICB9LCB0aGlzLnJlbmRlckVycm9yTWVzc2FnZSgpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgbmFtZTogXCJib2R5XCIsXG4gICAgICBpZDogaWQgJiYgaWQgKyAnLWJvZHknLFxuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIG92ZXJmbG93OiAnbm9uZScsXG4gICAgICAgIGhlaWdodDogaGFzRXJyb3IgPyAnY2FsYygxMDAlIC0gNjBweCknIDogJzEwMCUnLFxuICAgICAgICB3aWR0aDogJycsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcmVzaXplOiAnbm9uZScsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdSb2JvdG8gTW9ubywgTW9uYWNvLCBtb25vc3BhY2UnLFxuICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5iYWNrZ3JvdW5kLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcwLjJzJyxcbiAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnY3ViaWMtYmV6aWVyKDAsIDEsIDAuNSwgMSknXG4gICAgICB9LCBzdHlsZS5ib2R5KSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIG5hbWU6IFwibGFiZWxzXCIsXG4gICAgICBpZDogaWQgJiYgaWQgKyAnLWxhYmVscycsXG4gICAgICByZWY6IHJlZiA9PiB0aGlzLnJlZkxhYmVscyA9IHJlZixcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHdpZHRoOiAnNDRweCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogJzVweCAwcHggNXB4IDEwcHgnLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGNvbG9yOiAnI0Q0RDRENCdcbiAgICAgIH0sIHN0eWxlLmxhYmVsQ29sdW1uKSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0sIHRoaXMucmVuZGVyTGFiZWxzKCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICByZWY6IHJlZiA9PiB0aGlzLnJlZkNvbnRlbnQgPSByZWYsXG4gICAgICBjb250ZW50RWRpdGFibGU6IHRydWUsXG4gICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICB3aWR0aDogJycsXG4gICAgICAgIGZsZXg6IDEsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogJzVweCcsXG4gICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICB3b3JkV3JhcDogJ2JyZWFrLXdvcmQnLFxuICAgICAgICB3aGl0ZVNwYWNlOiAncHJlLWxpbmUnLFxuICAgICAgICBjb2xvcjogJyNENEQ0RDQnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZSdcbiAgICAgIH0sIHN0eWxlLmNvbnRlbnRCb3gpLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRoaXMuY3JlYXRlTWFya3VwKG1hcmt1cFRleHQpLFxuICAgICAgb25LZXlQcmVzczogdGhpcy5vbktleVByZXNzLFxuICAgICAgb25LZXlEb3duOiB0aGlzLm9uS2V5RG93bixcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGljayxcbiAgICAgIG9uQmx1cjogdGhpcy5vbkJsdXIsXG4gICAgICBvblNjcm9sbDogdGhpcy5vblNjcm9sbCxcbiAgICAgIG9uUGFzdGU6IHRoaXMub25QYXN0ZSxcbiAgICAgIGF1dG9Db21wbGV0ZTogXCJvZmZcIixcbiAgICAgIGF1dG9Db3JyZWN0OiBcIm9mZlwiLFxuICAgICAgYXV0b0NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICBzcGVsbENoZWNrOiBmYWxzZVxuICAgIH0pKSkpO1xuICB9XG5cbiAgcmVuZGVyRXJyb3JNZXNzYWdlKCkge1xuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMucHJvcHMubG9jYWxlIHx8IGRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgZXJyb3IgPSB0aGlzLnByb3BzLmVycm9yIHx8IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIGlmICghZXJyb3IpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6ICdjYWxjKDEwMCUgLSA2MHB4KScsXG4gICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6ICcxMHB4JyxcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgICAgfSwgc3R5bGUuZXJyb3JNZXNzYWdlKVxuICAgIH0sIGZvcm1hdChsb2NhbGUuZm9ybWF0LCBlcnJvcikpO1xuICB9XG5cbiAgcmVuZGVyTGFiZWxzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuY29sb3JzLFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5zdHlsZSxcbiAgICAgICAgICBlcnJvciA9IHRoaXMucHJvcHMuZXJyb3IgfHwgdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICBlcnJvckxpbmUgPSBlcnJvciA/IGVycm9yLmxpbmUgOiAtMSxcbiAgICAgICAgICBsaW5lcyA9IHRoaXMuc3RhdGUubGluZXMgPyB0aGlzLnN0YXRlLmxpbmVzIDogMTtcbiAgICBsZXQgbGFiZWxzID0gbmV3IEFycmF5KGxpbmVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMgLSAxOyBpKyspIGxhYmVsc1tpXSA9IGkgKyAxO1xuXG4gICAgcmV0dXJuIGxhYmVscy5tYXAobnVtYmVyID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gbnVtYmVyICE9PSBlcnJvckxpbmUgPyBjb2xvcnMuZGVmYXVsdCA6ICdyZWQnO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IG51bWJlcixcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe30sIHN0eWxlLmxhYmVscywge1xuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9KVxuICAgICAgfSwgbnVtYmVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZU1hcmt1cChtYXJrdXBUZXh0KSB7XG4gICAgaWYgKG1hcmt1cFRleHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHtcbiAgICAgIF9faHRtbDogJydcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBfX2h0bWw6ICcnICsgbWFya3VwVGV4dFxuICAgIH07XG4gIH1cblxuICBuZXdTcGFuKGksIHRva2VuLCBkZXB0aCkge1xuICAgIGxldCBjb2xvcnMgPSB0aGlzLmNvbG9ycyxcbiAgICAgICAgdHlwZSA9IHRva2VuLnR5cGUsXG4gICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSAnJztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjb2xvciA9IGNvbG9yc1t0b2tlbi50eXBlXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgIGlmIChzdHJpbmcgPT09ICcgJykgY29sb3IgPSBjb2xvcnMua2V5c193aGl0ZVNwYWNlO2Vsc2UgY29sb3IgPSBjb2xvcnMua2V5cztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIGlmIChzdHJpbmcgPT09ICc6JykgY29sb3IgPSBjb2xvcnMuY29sb247ZWxzZSBjb2xvciA9IGNvbG9ycy5kZWZhdWx0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29sb3IgPSBjb2xvcnMuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggIT09IHN0cmluZy5yZXBsYWNlKC88L2csICcnKS5yZXBsYWNlKC8+L2csICcnKS5sZW5ndGgpIHN0cmluZyA9ICc8eG1wIHN0eWxlPWRpc3BsYXk6aW5saW5lOz4nICsgc3RyaW5nICsgJzwveG1wPic7XG4gICAgcmV0dXJuICc8c3BhbicgKyAnIHR5cGU9XCInICsgdHlwZSArICdcIicgKyAnIHZhbHVlPVwiJyArIHN0cmluZyArICdcIicgKyAnIGRlcHRoPVwiJyArIGRlcHRoICsgJ1wiJyArICcgc3R5bGU9XCJjb2xvcjonICsgY29sb3IgKyAnXCInICsgJz4nICsgc3RyaW5nICsgJzwvc3Bhbj4nO1xuICB9XG5cbiAgZ2V0Q3Vyc29yUG9zaXRpb24oY291bnRCUikge1xuICAgIC8qKlxyXG4gICAgICogTmVlZCB0byBkZXByZWNhdGUgY291bnRCUlxyXG4gICAgICogSXQgaXMgdXNlZCB0byBkaWZmZXJlbmNpYXRlIGJldHdlZW4gZ29vZCBtYXJrdXAgcmVuZGVyLCBhbmQgYXV4IHJlbmRlciB3aGVuIGVycm9yIGZvdW5kXHJcbiAgICAgKiBBZGp1c3RtZW50cyBiYXNlZCBvbiBjb3VuZEJSIGFjY291bnQgZm9yIHVzYWdlIG9mIDxicj4gaW5zdGVhZCBvZiA8c3Bhbj4gZm9yIGxpbmVicmVha3MgdG8gZGV0ZXJtaW5lIGFjdXJhdGUgY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKiBGaW5kIGEgd2F5IHRvIGNvbnNvbGlkYXRlIHJlbmRlciBzdHlsZXNcclxuICAgICAqL1xuICAgIGNvbnN0IGlzQ2hpbGRPZiA9IG5vZGUgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucmVmQ29udGVudCkgcmV0dXJuIHRydWU7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgbGV0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgY2hhckNvdW50ID0gLTEsXG4gICAgICAgIGxpbmVicmVha0NvdW50ID0gMCxcbiAgICAgICAgbm9kZTtcblxuICAgIGlmIChzZWxlY3Rpb24uZm9jdXNOb2RlICYmIGlzQ2hpbGRPZihzZWxlY3Rpb24uZm9jdXNOb2RlKSkge1xuICAgICAgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICBjaGFyQ291bnQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnJlZkNvbnRlbnQpIGJyZWFrO1xuXG4gICAgICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAoY291bnRCUikgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIGxpbmVicmVha0NvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50ICs9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJDb3VudCArIGxpbmVicmVha0NvdW50O1xuICB9XG5cbiAgc2V0Q3Vyc29yUG9zaXRpb24obmV4dFBvc2l0aW9uKSB7XG4gICAgaWYgKFtmYWxzZSwgbnVsbCwgdW5kZWZpbmVkXS5pbmRleE9mKG5leHRQb3NpdGlvbikgPiAtMSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY3JlYXRlUmFuZ2UgPSAobm9kZSwgY2hhcnMsIHJhbmdlKSA9PiB7XG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFycy5jb3VudCA9PT0gMCkge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgY2hhcnMuY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChub2RlICYmIGNoYXJzLmNvdW50ID4gMCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBpZiAobm9kZS50ZXh0Q29udGVudC5sZW5ndGggPCBjaGFycy5jb3VudCkgY2hhcnMuY291bnQgLT0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7ZWxzZSB7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgY2hhcnMuY291bnQpO1xuICAgICAgICAgICAgY2hhcnMuY291bnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGZvciAodmFyIGxwID0gMDsgbHAgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBscCsrKSB7XG4gICAgICAgICAgcmFuZ2UgPSBjcmVhdGVSYW5nZShub2RlLmNoaWxkTm9kZXNbbHBdLCBjaGFycywgcmFuZ2UpO1xuICAgICAgICAgIGlmIChjaGFycy5jb3VudCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRQb3NpdGlvbiA9IGNoYXJzID0+IHtcbiAgICAgIGlmIChjaGFycyA8IDApIHJldHVybjtcbiAgICAgIGxldCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgcmFuZ2UgPSBjcmVhdGVSYW5nZSh0aGlzLnJlZkNvbnRlbnQsIHtcbiAgICAgICAgY291bnQ6IGNoYXJzXG4gICAgICB9KTtcbiAgICAgIGlmICghcmFuZ2UpIHJldHVybjtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIGlmIChuZXh0UG9zaXRpb24gPiAwKSBzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO2Vsc2UgdGhpcy5yZWZDb250ZW50LmZvY3VzKCk7XG4gIH1cblxuICB1cGRhdGUoY3Vyc29yT2Zmc2V0ID0gMCwgdXBkYXRlQ3Vyc29yUG9zaXRpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5yZWZDb250ZW50LFxuICAgICAgICAgIGRhdGEgPSB0aGlzLnRva2VuaXplKGNvbnRhaW5lcik7XG4gICAgaWYgKCdvbkNoYW5nZScgaW4gdGhpcy5wcm9wcykgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICBwbGFpblRleHQ6IGRhdGEuaW5kZW50ZWQsXG4gICAgICBtYXJrdXBUZXh0OiBkYXRhLm1hcmt1cCxcbiAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgIGpzT2JqZWN0OiBkYXRhLmpzT2JqZWN0LFxuICAgICAgbGluZXM6IGRhdGEubGluZXMsXG4gICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgIH0pO1xuICAgIGxldCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oZGF0YS5lcnJvcikgKyBjdXJzb3JPZmZzZXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwbGFpblRleHQ6IGRhdGEuaW5kZW50ZWQsXG4gICAgICBtYXJrdXBUZXh0OiBkYXRhLm1hcmt1cCxcbiAgICAgIGpzb246IGRhdGEuanNvbixcbiAgICAgIGpzT2JqZWN0OiBkYXRhLmpzT2JqZWN0LFxuICAgICAgbGluZXM6IGRhdGEubGluZXMsXG4gICAgICBlcnJvcjogZGF0YS5lcnJvclxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVGltZSA9IGZhbHNlO1xuICAgIGlmICh1cGRhdGVDdXJzb3JQb3NpdGlvbikgdGhpcy5zZXRDdXJzb3JQb3NpdGlvbihjdXJzb3JQb3NpdGlvbik7XG4gIH1cblxuICBzY2hlZHVsZWRVcGRhdGUoKSB7XG4gICAgaWYgKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSBpZiAodGhpcy5wcm9wcy5vbktleVByZXNzVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHVwZGF0ZVRpbWVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodXBkYXRlVGltZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBpZiAodXBkYXRlVGltZSA+IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSByZXR1cm47XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHNldFVwZGF0ZVRpbWUoKSB7XG4gICAgaWYgKCdvbktleVByZXNzVXBkYXRlJyBpbiB0aGlzLnByb3BzKSBpZiAodGhpcy5wcm9wcy5vbktleVByZXNzVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy53YWl0QWZ0ZXJLZXlQcmVzcztcbiAgfVxuXG4gIHN0b3BFdmVudChldmVudCkge1xuICAgIGlmICghZXZlbnQpIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgb25LZXlQcmVzcyhldmVudCkge1xuICAgIGNvbnN0IGN0cmxPck1ldGFJc1ByZXNzZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgaWYgKHRoaXMucHJvcHMudmlld09ubHkgJiYgIWN0cmxPck1ldGFJc1ByZXNzZWQpIHRoaXMuc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAoIWN0cmxPck1ldGFJc1ByZXNzZWQpIHRoaXMuc2V0VXBkYXRlVGltZSgpO1xuICB9XG5cbiAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgY29uc3Qgdmlld09ubHkgPSAhIXRoaXMucHJvcHMudmlld09ubHk7XG4gICAgY29uc3QgY3RybE9yTWV0YUlzUHJlc3NlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlICdUYWInOlxuICAgICAgICB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGlmICh2aWV3T25seSkgYnJlYWs7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGV4dFwiLCBmYWxzZSwgXCIgIFwiKTtcbiAgICAgICAgdGhpcy5zZXRVcGRhdGVUaW1lKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgICAgaWYgKHZpZXdPbmx5KSB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMuc2V0VXBkYXRlVGltZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICB0aGlzLnNldFVwZGF0ZVRpbWUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmICh2aWV3T25seSAmJiAhY3RybE9yTWV0YUlzUHJlc3NlZCkgdGhpcy5zdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZpZXdPbmx5KSB0aGlzLnN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uUGFzdGUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy52aWV3T25seSkge1xuICAgICAgdGhpcy5zdG9wRXZlbnQoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JywgZmFsc2UsIHRleHQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIGlmICgndmlld09ubHknIGluIHRoaXMucHJvcHMpIGlmICh0aGlzLnByb3BzLnZpZXdPbmx5KSByZXR1cm47XG4gIH1cblxuICBvbkJsdXIoKSB7XG4gICAgaWYgKCd2aWV3T25seScgaW4gdGhpcy5wcm9wcykgaWYgKHRoaXMucHJvcHMudmlld09ubHkpIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnJlZkNvbnRlbnQsXG4gICAgICAgICAgZGF0YSA9IHRoaXMudG9rZW5pemUoY29udGFpbmVyKTtcbiAgICBpZiAoJ29uQmx1cicgaW4gdGhpcy5wcm9wcykgdGhpcy5wcm9wcy5vbkJsdXIoe1xuICAgICAgcGxhaW5UZXh0OiBkYXRhLmluZGVudGVkLFxuICAgICAgbWFya3VwVGV4dDogZGF0YS5tYXJrdXAsXG4gICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICBqc09iamVjdDogZGF0YS5qc09iamVjdCxcbiAgICAgIGxpbmVzOiBkYXRhLmxpbmVzLFxuICAgICAgZXJyb3I6IGRhdGEuZXJyb3JcbiAgICB9KTtcbiAgfVxuXG4gIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgdGhpcy5yZWZMYWJlbHMuc2Nyb2xsVG9wID0gZXZlbnQudGFyZ2V0LnNjcm9sbFRvcDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUludGVybmFsUHJvcHMoKTtcbiAgICB0aGlzLnNob3dQbGFjZWhvbGRlcigpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zaG93UGxhY2Vob2xkZXIoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICB9XG5cbiAgc2hvd1BsYWNlaG9sZGVyKCkge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyRG9lc05vdEV4aXN0ID0gISgncGxhY2Vob2xkZXInIGluIHRoaXMucHJvcHMpO1xuICAgIGlmIChwbGFjZWhvbGRlckRvZXNOb3RFeGlzdCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYWNlaG9sZGVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJIYXNFbXB0eVZhbHVlcyA9IFt1bmRlZmluZWQsIG51bGxdLmluZGV4T2YocGxhY2Vob2xkZXIpID4gLTE7XG4gICAgaWYgKHBsYWNlaG9sZGVySGFzRW1wdHlWYWx1ZXMpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBwcmV2UGxhY2Vob2xkZXIsXG4gICAgICBqc09iamVjdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc2V0Q29uZmlndXJhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyRGF0YVR5cGUgPSBnZXRUeXBlKHBsYWNlaG9sZGVyKTtcbiAgICBjb25zdCB1bmV4cGVjdGVkRGF0YVR5cGUgPSBbJ29iamVjdCcsICdhcnJheSddLmluZGV4T2YocGxhY2Vob2xkZXJEYXRhVHlwZSkgPT09IC0xO1xuICAgIGlmICh1bmV4cGVjdGVkRGF0YVR5cGUpIGVyci50aHJvd0Vycm9yKCdzaG93UGxhY2Vob2xkZXInLCAncGxhY2Vob2xkZXInLCAnZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheScpO1xuICAgIGNvbnN0IHNhbWVQbGFjZWhvbGRlclZhbHVlcyA9IGlkZW50aWNhbChwbGFjZWhvbGRlciwgcHJldlBsYWNlaG9sZGVyKTsgLy8gQ29tcG9uZW50IHdpbGwgYWx3YXlzIHJlLXJlbmRlciB3aGVuIG5ldyBwbGFjZWhvbGRlciB2YWx1ZSBpcyBhbnkgZGlmZmVyZW50IGZyb20gcHJldmlvdXMgcGxhY2Vob2xkZXIgdmFsdWUuXG5cbiAgICBsZXQgY29tcG9uZW50U2hvdWxkVXBkYXRlID0gIXNhbWVQbGFjZWhvbGRlclZhbHVlcztcblxuICAgIGlmICghY29tcG9uZW50U2hvdWxkVXBkYXRlKSB7XG4gICAgICBpZiAocmVzZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmICdyZXNldCcgcHJvcGVydHkgaXMgc2V0IHRydWUgb3IgaXMgdHJ1dGh5LFxyXG4gICAgICAgICAqIGFueSBkaWZmZXJlbmNlIGJldHdlZW4gcGxhY2Vob2xkZXIgYW5kIGN1cnJlbnQgdmFsdWVcclxuICAgICAgICAgKiBzaG91bGQgdHJpZ2dlciBjb21wb25lbnQgcmUtcmVuZGVyXHJcbiAgICAgICAgICovXG4gICAgICAgIGlmIChqc09iamVjdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRTaG91bGRVcGRhdGUgPSAhaWRlbnRpY2FsKHBsYWNlaG9sZGVyLCBqc09iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb21wb25lbnRTaG91bGRVcGRhdGUpIHJldHVybjtcbiAgICBjb25zdCBkYXRhID0gdGhpcy50b2tlbml6ZShwbGFjZWhvbGRlcik7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwcmV2UGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgcGxhaW5UZXh0OiBkYXRhLmluZGVudGF0aW9uLFxuICAgICAgbWFya3VwVGV4dDogZGF0YS5tYXJrdXAsXG4gICAgICBsaW5lczogZGF0YS5saW5lcyxcbiAgICAgIGVycm9yOiBkYXRhLmVycm9yXG4gICAgfSk7XG4gIH1cblxuICB0b2tlbml6ZShzb21ldGhpbmcpIHtcbiAgICBpZiAodHlwZW9mIHNvbWV0aGluZyAhPT0gJ29iamVjdCcpIHJldHVybiBjb25zb2xlLmVycm9yKCd0b2tlbml6ZSgpIGV4cGVjdHMgb2JqZWN0IHR5cGUgcHJvcGVydGllcyBvbmx5LiBHb3QgXFwnJyArIHR5cGVvZiBzb21ldGhpbmcgKyAnXFwnIHR5cGUgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLnByb3BzLmxvY2FsZSB8fCBkZWZhdWx0TG9jYWxlO1xuICAgIGNvbnN0IG5ld1NwYW4gPSB0aGlzLm5ld1NwYW47XG4gICAgLyoqXHJcbiAgICAgKiAgICAgRE9NIE5PREUgfHwgT05CTFVSIE9SIFVQREFURVxyXG4gICAgICovXG5cbiAgICBpZiAoJ25vZGVUeXBlJyBpbiBzb21ldGhpbmcpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBzb21ldGhpbmcuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgICAgaGFzQ2hpbGRyZW4gPSBjb250YWluZXJOb2RlLmhhc0NoaWxkTm9kZXMoKTtcbiAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHJldHVybiAnJztcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyTm9kZS5jaGlsZE5vZGVzO1xuICAgICAgbGV0IGJ1ZmZlciA9IHtcbiAgICAgICAgdG9rZW5zX3Vua25vd246IFtdLFxuICAgICAgICB0b2tlbnNfcHJvdG86IFtdLFxuICAgICAgICB0b2tlbnNfc3BsaXQ6IFtdLFxuICAgICAgICB0b2tlbnNfZmFsbGJhY2s6IFtdLFxuICAgICAgICB0b2tlbnNfbm9ybWFsaXplOiBbXSxcbiAgICAgICAgdG9rZW5zX21lcmdlOiBbXSxcbiAgICAgICAgdG9rZW5zX3BsYWluVGV4dDogJycsXG4gICAgICAgIGluZGVudGVkOiAnJyxcbiAgICAgICAganNvbjogJycsXG4gICAgICAgIGpzT2JqZWN0OiB1bmRlZmluZWQsXG4gICAgICAgIG1hcmt1cDogJydcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGxldCBpbmZvID0ge307XG5cbiAgICAgICAgc3dpdGNoIChjaGlsZC5ub2RlTmFtZSkge1xuICAgICAgICAgIGNhc2UgJ1NQQU4nOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBjaGlsZC50ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgdHlwZTogY2hpbGQuYXR0cmlidXRlcy50eXBlLnRleHRDb250ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVmZmVyLnRva2Vuc191bmtub3duLnB1c2goaW5mbyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0RJVic6XG4gICAgICAgICAgICBidWZmZXIudG9rZW5zX3Vua25vd24ucHVzaCh7XG4gICAgICAgICAgICAgIHN0cmluZzogY2hpbGQudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIHR5cGU6ICd1bmtub3duJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0JSJzpcbiAgICAgICAgICAgIGlmIChjaGlsZC50ZXh0Q29udGVudCA9PT0gJycpIGJ1ZmZlci50b2tlbnNfdW5rbm93bi5wdXNoKHtcbiAgICAgICAgICAgICAgc3RyaW5nOiAnXFxuJyxcbiAgICAgICAgICAgICAgdHlwZTogJ3Vua25vd24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnI3RleHQnOlxuICAgICAgICAgICAgYnVmZmVyLnRva2Vuc191bmtub3duLnB1c2goe1xuICAgICAgICAgICAgICBzdHJpbmc6IGNoaWxkLndob2xlVGV4dCxcbiAgICAgICAgICAgICAgdHlwZTogJ3Vua25vd24nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRk9OVCc6XG4gICAgICAgICAgICBidWZmZXIudG9rZW5zX3Vua25vd24ucHVzaCh7XG4gICAgICAgICAgICAgIHN0cmluZzogY2hpbGQudGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIHR5cGU6ICd1bmtub3duJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbnJlY29nbml6ZWQgbm9kZTonLCB7XG4gICAgICAgICAgICAgIGNoaWxkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHF1YXJraXplKHRleHQsIHByZWZpeCA9ICcnKSB7XG4gICAgICAgIGxldCBidWZmZXIgPSB7XG4gICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBzdHJpbmc6ICcnLFxuICAgICAgICAgIG51bWJlcjogJycsXG4gICAgICAgICAgc3ltYm9sOiAnJyxcbiAgICAgICAgICBzcGFjZTogJycsXG4gICAgICAgICAgZGVsaW1pdGVyOiAnJyxcbiAgICAgICAgICBxdWFya3M6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaEFuZFN0b3JlKGNoYXIsIHR5cGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBjYXNlICdkZWxpbWl0ZXInOlxuICAgICAgICAgICAgICBpZiAoYnVmZmVyLmFjdGl2ZSkgYnVmZmVyLnF1YXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IGJ1ZmZlcltidWZmZXIuYWN0aXZlXSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcmVmaXggKyAnLScgKyBidWZmZXIuYWN0aXZlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBidWZmZXJbYnVmZmVyLmFjdGl2ZV0gPSAnJztcbiAgICAgICAgICAgICAgYnVmZmVyLmFjdGl2ZSA9IHR5cGU7XG4gICAgICAgICAgICAgIGJ1ZmZlcltidWZmZXIuYWN0aXZlXSA9IGNoYXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gYnVmZmVyLmFjdGl2ZSB8fCBbYnVmZmVyLnN0cmluZywgY2hhcl0uaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYWN0aXZlKSBidWZmZXIucXVhcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgc3RyaW5nOiBidWZmZXJbYnVmZmVyLmFjdGl2ZV0sXG4gICAgICAgICAgICAgICAgICB0eXBlOiBwcmVmaXggKyAnLScgKyBidWZmZXIuYWN0aXZlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2J1ZmZlci5hY3RpdmVdID0gJyc7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFjdGl2ZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2J1ZmZlci5hY3RpdmVdID0gY2hhcjtcbiAgICAgICAgICAgICAgfSBlbHNlIGJ1ZmZlclt0eXBlXSArPSBjaGFyO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsUHVzaCgpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgYnVmZmVyLnF1YXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgc3RyaW5nOiBidWZmZXJbYnVmZmVyLmFjdGl2ZV0sXG4gICAgICAgICAgICAgIHR5cGU6IHByZWZpeCArICctJyArIGJ1ZmZlci5hY3RpdmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnVmZmVyW2J1ZmZlci5hY3RpdmVdID0gJyc7XG4gICAgICAgICAgICBidWZmZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGkpO1xuXG4gICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICBwdXNoQW5kU3RvcmUoY2hhciwgJ2RlbGltaXRlcicpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBjYXNlICdcXHUwMEEwJzpcbiAgICAgICAgICAgICAgcHVzaEFuZFN0b3JlKGNoYXIsICdzcGFjZScpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICBwdXNoQW5kU3RvcmUoY2hhciwgJ3N5bWJvbCcpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgIGlmIChidWZmZXIuYWN0aXZlID09PSAnc3RyaW5nJykgcHVzaEFuZFN0b3JlKGNoYXIsICdzdHJpbmcnKTtlbHNlIHB1c2hBbmRTdG9yZShjaGFyLCAnbnVtYmVyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgaWYgKGkgPCB0ZXh0Lmxlbmd0aCAtIDEpIGlmICgnMDEyMzQ1Njc4OScuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwdXNoQW5kU3RvcmUoY2hhciwgJ251bWJlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICBpZiAoaSA8IHRleHQubGVuZ3RoIC0gMSAmJiBpID4gMCkgaWYgKCcwMTIzNDU2Nzg5Jy5pbmRleE9mKHRleHQuY2hhckF0KGkgKyAxKSkgPiAtMSAmJiAnMDEyMzQ1Njc4OScuaW5kZXhPZih0ZXh0LmNoYXJBdChpIC0gMSkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwdXNoQW5kU3RvcmUoY2hhciwgJ251bWJlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHB1c2hBbmRTdG9yZShjaGFyLCAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsUHVzaCgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyLnF1YXJrcztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX3Vua25vd24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyLnRva2Vuc191bmtub3duW2ldO1xuICAgICAgICBidWZmZXIudG9rZW5zX3Byb3RvID0gYnVmZmVyLnRva2Vuc19wcm90by5jb25jYXQocXVhcmtpemUodG9rZW4uc3RyaW5nLCAncHJvdG8nKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkVG9rZW4oc3RyaW5nLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlcyA9ICdcXCdcIic7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSAnJyxcbiAgICAgICAgICAgIGxhc3RDaGFyID0gJycsXG4gICAgICAgICAgICBxdW90ZVR5cGUgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgICAgICAgaWYgKFsndHJ1ZScsICdmYWxzZScsICdudWxsJywgJ3VuZGVmaW5lZCddLmluZGV4T2Yoc3RyaW5nKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZmlyc3RDaGFyID0gc3RyaW5nLmNoYXJBdCgwKSwgbGFzdENoYXIgPSBzdHJpbmcuY2hhckF0KHN0cmluZy5sZW5ndGggLSAxKSwgcXVvdGVUeXBlID0gcXVvdGVzLmluZGV4T2YoZmlyc3RDaGFyKTtcbiAgICAgICAgICAgIGlmIChxdW90ZVR5cGUgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyICE9PSBsYXN0Q2hhcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgaSA8IHN0cmluZy5sZW5ndGggLSAxKSBpZiAoc3RyaW5nLmNoYXJBdChpKSA9PT0gcXVvdGVzW3F1b3RlVHlwZV0pIGlmIChzdHJpbmcuY2hhckF0KGkgLSAxKSAhPT0gJ1xcXFwnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAna2V5JzpcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApLCBsYXN0Q2hhciA9IHN0cmluZy5jaGFyQXQoc3RyaW5nLmxlbmd0aCAtIDEpLCBxdW90ZVR5cGUgPSBxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpO1xuXG4gICAgICAgICAgICBpZiAocXVvdGVUeXBlID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciAhPT0gbGFzdENoYXIpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBpIDwgc3RyaW5nLmxlbmd0aCAtIDEpIGlmIChzdHJpbmcuY2hhckF0KGkpID09PSBxdW90ZXNbcXVvdGVUeXBlXSkgaWYgKHN0cmluZy5jaGFyQXQoaSAtIDEpICE9PSAnXFxcXCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9uQWxwaGFudW1lcmljID0gJ1xcJ1wiYC4sOjt7fVtdJjw+PX4qJVxcXFx8Ly0rIT9AXiBcXHhhMCc7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25BbHBoYW51bWVyaWMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25BbHBoYSA9IG5vbkFscGhhbnVtZXJpYy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKG5vbkFscGhhKSA+IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCcwMTIzNDU2Nzg5Jy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaSkpID09PSAtMSkgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoJy0nICE9PSBzdHJpbmcuY2hhckF0KDApKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJy4nICE9PSBzdHJpbmcuY2hhckF0KGkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCd7WzpdfSwnLmluZGV4T2Yoc3RyaW5nKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY29sb24nOlxuICAgICAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoJzonICE9PSBzdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX3Byb3RvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfcHJvdG9baV07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUuaW5kZXhPZigncHJvdG8nKSA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoIXZhbGlkVG9rZW4odG9rZW4uc3RyaW5nLCB0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgYnVmZmVyLnRva2Vuc19zcGxpdCA9IGJ1ZmZlci50b2tlbnNfc3BsaXQuY29uY2F0KHF1YXJraXplKHRva2VuLnN0cmluZywgJ3NwbGl0JykpO1xuICAgICAgICAgIH0gZWxzZSBidWZmZXIudG9rZW5zX3NwbGl0LnB1c2godG9rZW4pO1xuICAgICAgICB9IGVsc2UgYnVmZmVyLnRva2Vuc19zcGxpdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX3NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfc3BsaXRbaV07XG4gICAgICAgIGxldCB0eXBlID0gdG9rZW4udHlwZSxcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZyxcbiAgICAgICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICBmYWxsYmFjayA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGUuc2xpY2UodHlwZS5pbmRleE9mKCctJykgKyAxKTtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIGZhbGxiYWNrLnB1c2goJ3N0cmluZycpO1xuICAgICAgICAgIGZhbGxiYWNrLnB1c2goJ2tleScpO1xuICAgICAgICAgIGZhbGxiYWNrLnB1c2goJ2Vycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rdWwgPSB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBmYWxsYmFjazogZmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgYnVmZmVyLnRva2Vuc19mYWxsYmFjay5wdXNoKHRva3VsKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9rZW5Gb2xsb3dlZCgpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IGJ1ZmZlci50b2tlbnNfbm9ybWFsaXplLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSBidWZmZXIudG9rZW5zX25vcm1hbGl6ZVtpXTtcblxuICAgICAgICAgIHN3aXRjaCAocHJldmlvdXNUb2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdsaW5lYnJlYWsnOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVG9rZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJ1ZmZlcjIgPSB7XG4gICAgICAgIGJyYWNrZXRzOiBbXSxcbiAgICAgICAgc3RyaW5nT3BlbjogZmFsc2UsXG4gICAgICAgIGlzVmFsdWU6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfZmFsbGJhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyLnRva2Vuc19mYWxsYmFja1tpXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuLnR5cGUsXG4gICAgICAgICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZztcbiAgICAgICAgbGV0IG5vcm1hbFRva2VuID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgIGNhc2UgJ2NvbG9uJzpcbiAgICAgICAgICAgIGlmIChidWZmZXIyLnN0cmluZ09wZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgbm9ybWFsVG9rZW4udHlwZSA9ICdzdHJpbmcnO2Vsc2Ugbm9ybWFsVG9rZW4udHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIGJ1ZmZlcjIuYnJhY2tldHMucHVzaChzdHJpbmcpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICBidWZmZXIyLmJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbkZvbGxvd2VkKCkudHlwZSA9PT0gJ2NvbG9uJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgbm9ybWFsVG9rZW4udHlwZSA9ICdjb2xvbic7XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkZWxpbWl0ZXInOlxuICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgbm9ybWFsVG9rZW4udHlwZSA9ICdzdHJpbmcnO2Vsc2Ugbm9ybWFsVG9rZW4udHlwZSA9ICdrZXknO1xuXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlcjIuc3RyaW5nT3Blbikge1xuICAgICAgICAgICAgICBidWZmZXIyLnN0cmluZ09wZW4gPSBzdHJpbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGJ1ZmZlci50b2tlbnNfZmFsbGJhY2tbaSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBfc3RyaW5nID0gcHJldmlvdXNUb2tlbi5zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIF90eXBlID0gcHJldmlvdXNUb2tlbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBfY2hhciA9IF9zdHJpbmcuY2hhckF0KF9zdHJpbmcubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgICAgaWYgKF90eXBlID09PSAnc3RyaW5nJyAmJiBfY2hhciA9PT0gJ1xcXFwnKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuc3RyaW5nT3BlbiA9PT0gc3RyaW5nKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjIuc3RyaW5nT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAoWydmYWxzZScsICd0cnVlJywgJ251bGwnLCAndW5kZWZpbmVkJ10uaW5kZXhPZihzdHJpbmcpID4gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gYnVmZmVyLnRva2Vuc19ub3JtYWxpemUubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRva2Vuc19ub3JtYWxpemVbbGFzdEluZGV4XS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgbm9ybWFsVG9rZW4udHlwZSA9ICdwcmltaXRpdmUnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9ybWFsVG9rZW4udHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbm9ybWFsVG9rZW4udHlwZSA9ICdwcmltaXRpdmUnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ1xcbicpIGlmICghYnVmZmVyMi5zdHJpbmdPcGVuKSB7XG4gICAgICAgICAgICAgIG5vcm1hbFRva2VuLnR5cGUgPSAnbGluZWJyZWFrJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyMi5pc1ZhbHVlKSBub3JtYWxUb2tlbi50eXBlID0gJ3N0cmluZyc7ZWxzZSBub3JtYWxUb2tlbi50eXBlID0gJ2tleSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGlmIChidWZmZXIyLnN0cmluZ09wZW4pIGlmIChidWZmZXIyLmlzVmFsdWUpIG5vcm1hbFRva2VuLnR5cGUgPSAnc3RyaW5nJztlbHNlIG5vcm1hbFRva2VuLnR5cGUgPSAna2V5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGlmIChidWZmZXIyLnN0cmluZ09wZW4pIGlmIChidWZmZXIyLmlzVmFsdWUpIG5vcm1hbFRva2VuLnR5cGUgPSAnc3RyaW5nJztlbHNlIG5vcm1hbFRva2VuLnR5cGUgPSAna2V5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyLnRva2Vuc19ub3JtYWxpemUucHVzaChub3JtYWxUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnRva2Vuc19ub3JtYWxpemUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBidWZmZXIudG9rZW5zX25vcm1hbGl6ZVtpXTtcbiAgICAgICAgbGV0IG1lcmdlZFRva2VuID0ge1xuICAgICAgICAgIHN0cmluZzogdG9rZW4uc3RyaW5nLFxuICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUsXG4gICAgICAgICAgdG9rZW5zOiBbaV1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFsnc3ltYm9sJywgJ2NvbG9uJ10uaW5kZXhPZih0b2tlbi50eXBlKSA9PT0gLTEpIGlmIChpICsgMSA8IGJ1ZmZlci50b2tlbnNfbm9ybWFsaXplLmxlbmd0aCkge1xuICAgICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciB1ID0gaSArIDE7IHUgPCBidWZmZXIudG9rZW5zX25vcm1hbGl6ZS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gYnVmZmVyLnRva2Vuc19ub3JtYWxpemVbdV07XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gbmV4dFRva2VuLnR5cGUpIGJyZWFrO1xuICAgICAgICAgICAgbWVyZ2VkVG9rZW4uc3RyaW5nICs9IG5leHRUb2tlbi5zdHJpbmc7XG4gICAgICAgICAgICBtZXJnZWRUb2tlbi50b2tlbnMucHVzaCh1KTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIudG9rZW5zX21lcmdlLnB1c2gobWVyZ2VkVG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBxdW90ZXMgPSAnXFwnXCInLFxuICAgICAgICAgICAgYWxwaGFudW1lcmljID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnMDEyMzQ1Njc4OScgKyAnXyQnO1xuICAgICAgdmFyIGVycm9yID0gZmFsc2UsXG4gICAgICAgICAgbGluZSA9IGJ1ZmZlci50b2tlbnNfbWVyZ2UubGVuZ3RoID4gMCA/IDEgOiAwO1xuICAgICAgYnVmZmVyMiA9IHtcbiAgICAgICAgYnJhY2tldHM6IFtdLFxuICAgICAgICBzdHJpbmdPcGVuOiBmYWxzZSxcbiAgICAgICAgaXNWYWx1ZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHNldEVycm9yKHRva2VuSUQsIHJlYXNvbiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICB0b2tlbjogdG9rZW5JRCxcbiAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgIH07XG4gICAgICAgIGJ1ZmZlci50b2tlbnNfbWVyZ2VbdG9rZW5JRCArIG9mZnNldF0udHlwZSA9ICdlcnJvcic7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvbGxvd2VkQnlTeW1ib2wodG9rZW5JRCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodG9rZW5JRCA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmVycm9yKCd0b2tlbklEIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgY29uc29sZS5lcnJvcignb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICBpZiAodG9rZW5JRCA9PT0gYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGggLSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHRva2VuSUQgKyAxOyBpIDwgYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV07XG5cbiAgICAgICAgICBzd2l0Y2ggKG5leHRUb2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdsaW5lYnJlYWsnOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9uJzpcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXhPZihuZXh0VG9rZW4uc3RyaW5nKSA+IC0xKSByZXR1cm4gaTtlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmb2xsb3dzU3ltYm9sKHRva2VuSUQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRva2VuSUQgPT09IHVuZGVmaW5lZCkgY29uc29sZS5lcnJvcigndG9rZW5JRCBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIGNvbnNvbGUuZXJyb3IoJ29wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgaWYgKHRva2VuSUQgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdG9rZW5JRCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV07XG5cbiAgICAgICAgICBzd2l0Y2ggKHByZXZpb3VzVG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBjYXNlICdjb2xvbic6XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGV4T2YocHJldmlvdXNUb2tlbi5zdHJpbmcpID4gLTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHlwZUZvbGxvd2VkKHRva2VuSUQpIHtcbiAgICAgICAgaWYgKHRva2VuSUQgPT09IHVuZGVmaW5lZCkgY29uc29sZS5lcnJvcigndG9rZW5JRCBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgIGlmICh0b2tlbklEID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHRva2VuSUQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSBidWZmZXIudG9rZW5zX21lcmdlW2ldO1xuXG4gICAgICAgICAgc3dpdGNoIChwcmV2aW91c1Rva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNUb2tlbi50eXBlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBicmFja2V0TGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci50b2tlbnNfbWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVycm9yKSBicmVhaztcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXSxcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZyxcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlbi50eXBlLFxuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgZm91bmQgPSBmb2xsb3dzU3ltYm9sKGksIFsnfScsICddJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50b2tlblNlcXVlbmNlLnByb2hpYml0ZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RUb2tlbjogYnVmZmVyLnRva2Vuc19tZXJnZVtmb3VuZF0uc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogc3RyaW5nXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnWycgJiYgaSA+IDApIGlmICghZm9sbG93c1N5bWJvbChpLCBbJzonLCAnWycsICcsJ10pKSB7XG4gICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50b2tlblNlcXVlbmNlLnBlcm1pdHRlZCwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIltcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFtcIjpcIiwgXCJbXCIsIFwiLFwiXVxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgPT09ICd7JykgaWYgKGZvbGxvd3NTeW1ib2woaSwgWyd7J10pKSB7XG4gICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi5kb3VibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IFwie1wiXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5icmFja2V0cy5wdXNoKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgICAgICAgICAgYnJhY2tldExpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgPT09ICd9JykgaWYgKGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSAhPT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmJyYWNlLmN1cmx5Lm1pc3NpbmdPcGVuKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ30nKSBpZiAoZm9sbG93c1N5bWJvbChpLCBbJywnXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIixcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFwifVwiXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ10nKSBpZiAoYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdICE9PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuYnJhY2Uuc3F1YXJlLm1pc3NpbmdPcGVuKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gJ10nKSBpZiAoZm9sbG93c1N5bWJvbChpLCBbJzonXSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIjpcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFwiXVwiXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyMi5icmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgICAgICBicmFja2V0TGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvbGxvd3NTeW1ib2woaSwgWyd7J10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZm9sbG93ZWRCeVN5bWJvbChpLCBbJ30nXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5icmFjZS5jdXJseS5jYW5ub3RXcmFwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW46IFwiLFwiXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiBcIntcIixcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFwiLFwiXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9sbG93ZWRCeVN5bWJvbChpLCBbJ30nLCAnLCcsICddJ10pKSB7XG4gICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLm5vVHJhaWxpbmdPckxlYWRpbmdDb21tYSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0eXBlRm9sbG93ZWQoaSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnY29sb24nOlxuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmludmFsaWRUb2tlbi50ZXJtU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VGVybTogZm91bmQgPT09ICdrZXknID8gbG9jYWxlLnR5cGVzLmtleSA6IGxvY2FsZS5zeW1ib2xzLmNvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFRlcm06IGxvY2FsZS5zeW1ib2xzLmNvbW1hXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xsb3dzU3ltYm9sKGksIFsneyddKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucHJvaGliaXRlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RUb2tlbjogXCJ7XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogXCIsXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyMi5pc1ZhbHVlID0gYnVmZmVyMi5icmFja2V0c1tidWZmZXIyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyLmpzb24gKz0gc3RyaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjb2xvbic6XG4gICAgICAgICAgICBmb3VuZCA9IGZvbGxvd3NTeW1ib2woaSwgWydbJ10pO1xuXG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgZm9sbG93ZWRCeVN5bWJvbChpLCBbJ10nXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5icmFjZS5zcXVhcmUuY2Fubm90V3JhcCwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcIjpcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wcm9oaWJpdGVkLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RUb2tlbjogXCJbXCIsXG4gICAgICAgICAgICAgICAgc2Vjb25kVG9rZW46IFwiOlwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlRm9sbG93ZWQoaSkgIT09ICdrZXknKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRlcm1TZXF1ZW5jZS5wZXJtaXR0ZWQsIHtcbiAgICAgICAgICAgICAgICBmaXJzdFRlcm06IGxvY2FsZS5zeW1ib2xzLmNvbG9uLFxuICAgICAgICAgICAgICAgIHNlY29uZFRlcm06IGxvY2FsZS50eXBlcy5rZXlcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvbGxvd2VkQnlTeW1ib2woaSwgWyd9JywgJ10nXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udGVybVNlcXVlbmNlLnBlcm1pdHRlZCwge1xuICAgICAgICAgICAgICAgIGZpcnN0VGVybTogbG9jYWxlLnN5bWJvbHMuY29sb24sXG4gICAgICAgICAgICAgICAgc2Vjb25kVGVybTogbG9jYWxlLnR5cGVzLnZhbHVlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBidWZmZXIuanNvbiArPSBzdHJpbmc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGxldCBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApLFxuICAgICAgICAgICAgICAgIGxhc3RDaGFyID0gc3RyaW5nLmNoYXJBdChzdHJpbmcubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgcXVvdGVfcHJpbWFyeSA9IHF1b3Rlcy5pbmRleE9mKGZpcnN0Q2hhcik7XG4gICAgICAgICAgICBpZiAocXVvdGVzLmluZGV4T2YoZmlyc3RDaGFyKSA9PT0gLTEpIGlmIChxdW90ZXMuaW5kZXhPZihsYXN0Q2hhcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLm1pc3NpbmdPcGVuLCB7XG4gICAgICAgICAgICAgICAgcXVvdGU6IGZpcnN0Q2hhclxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1b3Rlcy5pbmRleE9mKGxhc3RDaGFyKSA9PT0gLTEpIGlmIChxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLnN0cmluZy5taXNzaW5nQ2xvc2UsIHtcbiAgICAgICAgICAgICAgICBxdW90ZTogZmlyc3RDaGFyXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGVzLmluZGV4T2YoZmlyc3RDaGFyKSA+IC0xKSBpZiAoZmlyc3RDaGFyICE9PSBsYXN0Q2hhcikge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLnN0cmluZy5taXNzaW5nQ2xvc2UsIHtcbiAgICAgICAgICAgICAgICBxdW90ZTogZmlyc3RDaGFyXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGUpIGlmIChxdW90ZXMuaW5kZXhPZihmaXJzdENoYXIpID09PSAtMSAmJiBxdW90ZXMuaW5kZXhPZihsYXN0Q2hhcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLm11c3RCZVdyYXBwZWRCeVF1b3RlcykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgna2V5JyA9PT0gdHlwZSkgaWYgKGZvbGxvd2VkQnlTeW1ib2woaSwgWyd9JywgJ10nXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udGVybVNlcXVlbmNlLnBlcm1pdHRlZCwge1xuICAgICAgICAgICAgICAgIGZpcnN0VGVybTogbG9jYWxlLnR5cGVzLmtleSxcbiAgICAgICAgICAgICAgICBzZWNvbmRUZXJtOiBsb2NhbGUuc3ltYm9scy5jb2xvblxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGVzLmluZGV4T2YoZmlyc3RDaGFyKSA9PT0gLTEgJiYgcXVvdGVzLmluZGV4T2YobGFzdENoYXIpID09PSAtMSkgZm9yICh2YXIgaCA9IDA7IGggPCBzdHJpbmcubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKSBicmVhaztcbiAgICAgICAgICAgICAgY29uc3QgYyA9IHN0cmluZy5jaGFyQXQoaCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFscGhhbnVtZXJpYy5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuc3RyaW5nLm5vbkFscGhhbnVtZXJpYywge1xuICAgICAgICAgICAgICAgICAgdG9rZW46IGNcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09IFwiJ1wiKSBzdHJpbmcgPSAnXCInICsgc3RyaW5nLnNsaWNlKDEsIC0xKSArICdcIic7ZWxzZSBpZiAoZmlyc3RDaGFyICE9PSAnXCInKSBzdHJpbmcgPSAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICAgICAgICAgIGlmICgna2V5JyA9PT0gdHlwZSkgaWYgKCdrZXknID09PSB0eXBlRm9sbG93ZWQoaSkpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPiAwKSBpZiAoIWlzTmFOKGJ1ZmZlci50b2tlbnNfbWVyZ2VbaSAtIDFdKSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci50b2tlbnNfbWVyZ2VbaSAtIDFdICs9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV07XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5rZXkubnVtYmVyQW5kTGV0dGVyTWlzc2luZ1F1b3RlcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUua2V5LnNwYWNlTWlzc2luZ1F1b3RlcykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgna2V5JyA9PT0gdHlwZSkgaWYgKCFmb2xsb3dzU3ltYm9sKGksIFsneycsICcsJ10pKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucGVybWl0dGVkLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RUb2tlbjogdHlwZSxcbiAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogW1wie1wiLCBcIixcIl1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkgaWYgKCFmb2xsb3dzU3ltYm9sKGksIFsnWycsICc6JywgJywnXSkpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udG9rZW5TZXF1ZW5jZS5wZXJtaXR0ZWQsIHtcbiAgICAgICAgICAgICAgICBmaXJzdFRva2VuOiB0eXBlLFxuICAgICAgICAgICAgICAgIHNlY29uZFRva2VuOiBbXCJbXCIsIFwiOlwiLCBcIixcIl1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgna2V5JyA9PT0gdHlwZSkgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLnN0cmluZy51bmV4cGVjdGVkS2V5KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlKSBpZiAoIWJ1ZmZlcjIuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICBzZXRFcnJvcihpLCBmb3JtYXQobG9jYWxlLmtleS51bmV4cGVjdGVkU3RyaW5nKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLmpzb24gKz0gc3RyaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNhc2UgJ3ByaW1pdGl2ZSc6XG4gICAgICAgICAgICBpZiAoZm9sbG93c1N5bWJvbChpLCBbJ3snXSkpIHtcbiAgICAgICAgICAgICAgYnVmZmVyLnRva2Vuc19tZXJnZVtpXS50eXBlID0gJ2tleSc7XG4gICAgICAgICAgICAgIHR5cGUgPSBidWZmZXIudG9rZW5zX21lcmdlW2ldLnR5cGU7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlRm9sbG93ZWQoaSkgPT09ICdrZXknKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV0udHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICB0eXBlID0gYnVmZmVyLnRva2Vuc19tZXJnZVtpXS50eXBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZm9sbG93c1N5bWJvbChpLCBbJ1snLCAnOicsICcsJ10pKSB7XG4gICAgICAgICAgICAgIHNldEVycm9yKGksIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnRva2VuU2VxdWVuY2UucGVybWl0dGVkLCB7XG4gICAgICAgICAgICAgICAgZmlyc3RUb2tlbjogdHlwZSxcbiAgICAgICAgICAgICAgICBzZWNvbmRUb2tlbjogW1wiW1wiLCBcIjpcIiwgXCIsXCJdXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAna2V5JykgaWYgKCFidWZmZXIyLmlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgYnVmZmVyLnRva2Vuc19tZXJnZVtpXS50eXBlID0gJ2tleSc7XG4gICAgICAgICAgICAgIHR5cGUgPSBidWZmZXIudG9rZW5zX21lcmdlW2ldLnR5cGU7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSBpZiAoc3RyaW5nID09PSAndW5kZWZpbmVkJykgc2V0RXJyb3IoaSwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udXNlSW5zdGVhZCwge1xuICAgICAgICAgICAgICBiYWRUb2tlbjogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgZ29vZFRva2VuOiBcIm51bGxcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYnVmZmVyLmpzb24gKz0gc3RyaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG5vRXNjYXBlZFNpbmdsZVF1b3RlID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBidWZmZXIuanNvbi5jaGFyQXQoaSksXG4gICAgICAgICAgICBuZXh0ID0gJyc7XG5cbiAgICAgICAgaWYgKGkgKyAxIDwgYnVmZmVyLmpzb24ubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5qc29uLmNoYXJBdChpICsgMSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gJ1xcXFwnICYmIG5leHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICBub0VzY2FwZWRTaW5nbGVRdW90ZSArPSBuZXh0O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9Fc2NhcGVkU2luZ2xlUXVvdGUgKz0gY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgYnVmZmVyLmpzb24gPSBub0VzY2FwZWRTaW5nbGVRdW90ZTtcblxuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gTWF0aC5jZWlsKGJyYWNrZXRMaXN0Lmxlbmd0aCAvIDIpO1xuICAgICAgICBsZXQgcm91bmQgPSAwLFxuICAgICAgICAgICAgZGVsdGEgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVQYWlyKGluZGV4KSB7XG4gICAgICAgICAgYnJhY2tldExpc3Quc3BsaWNlKGluZGV4ICsgMSwgMSk7XG4gICAgICAgICAgYnJhY2tldExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpZiAoIWRlbHRhKSBkZWx0YSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYnJhY2tldExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlbHRhID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciB0b2tlbkNvdW50ID0gMDsgdG9rZW5Db3VudCA8IGJyYWNrZXRMaXN0Lmxlbmd0aCAtIDE7IHRva2VuQ291bnQrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IGJyYWNrZXRMaXN0W3Rva2VuQ291bnRdLnN0cmluZyArIGJyYWNrZXRMaXN0W3Rva2VuQ291bnQgKyAxXS5zdHJpbmc7XG4gICAgICAgICAgICBpZiAoWydbXScsICd7fSddLmluZGV4T2YocGFpcikgPiAtMSkgcmVtb3ZlUGFpcih0b2tlbkNvdW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3VuZCsrO1xuICAgICAgICAgIGlmICghZGVsdGEpIGJyZWFrO1xuICAgICAgICAgIGlmIChyb3VuZCA+PSBtYXhJdGVyYXRpb25zKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicmFja2V0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgX3Rva2VuU3RyaW5nID0gYnJhY2tldExpc3RbMF0uc3RyaW5nLFxuICAgICAgICAgICAgICAgIF90b2tlblBvc2l0aW9uID0gYnJhY2tldExpc3RbMF0uaSxcbiAgICAgICAgICAgICAgICBfY2xvc2luZ0JyYWNrZXRUeXBlID0gX3Rva2VuU3RyaW5nID09PSAnWycgPyAnXScgOiAnfSc7XG5cbiAgICAgICAgICBsaW5lID0gYnJhY2tldExpc3RbMF0ubGluZTtcbiAgICAgICAgICBzZXRFcnJvcihfdG9rZW5Qb3NpdGlvbiwgZm9ybWF0KGxvY2FsZS5icmFjZVtfY2xvc2luZ0JyYWNrZXRUeXBlID09PSAnXScgPyAnc3F1YXJlJyA6ICdjdXJseSddLm1pc3NpbmdDbG9zZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXJyb3IpIGlmIChbdW5kZWZpbmVkLCAnJ10uaW5kZXhPZihidWZmZXIuanNvbikgPT09IC0xKSB0cnkge1xuICAgICAgICBidWZmZXIuanNPYmplY3QgPSBKU09OLnBhcnNlKGJ1ZmZlci5qc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgc3Vic01hcmsgPSBlcnJvck1lc3NhZ2UuaW5kZXhPZigncG9zaXRpb24nKTtcbiAgICAgICAgaWYgKHN1YnNNYXJrID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGZhaWxlZCcpO1xuICAgICAgICBjb25zdCBlcnJQb3NpdGlvblN0ciA9IGVycm9yTWVzc2FnZS5zdWJzdHJpbmcoc3Vic01hcmsgKyA5LCBlcnJvck1lc3NhZ2UubGVuZ3RoKSxcbiAgICAgICAgICAgICAgZXJyUG9zaXRpb24gPSBwYXJzZUludChlcnJQb3NpdGlvblN0cik7XG4gICAgICAgIGxldCBjaGFyVG90YWwgPSAwLFxuICAgICAgICAgICAgdG9rZW5JbmRleCA9IDAsXG4gICAgICAgICAgICB0b2tlbiA9IGZhbHNlLFxuICAgICAgICAgICAgX2xpbmUgPSAxLFxuICAgICAgICAgICAgZXhpdFdoaWxlID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGNoYXJUb3RhbCA8IGVyclBvc2l0aW9uICYmICFleGl0V2hpbGUpIHtcbiAgICAgICAgICB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbdG9rZW5JbmRleF07XG4gICAgICAgICAgaWYgKCdsaW5lYnJlYWsnID09PSB0b2tlbi50eXBlKSBfbGluZSsrO1xuICAgICAgICAgIGlmIChbJ3NwYWNlJywgJ2xpbmVicmVhayddLmluZGV4T2YodG9rZW4udHlwZSkgPT09IC0xKSBjaGFyVG90YWwgKz0gdG9rZW4uc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY2hhclRvdGFsID49IGVyclBvc2l0aW9uKSBicmVhaztcbiAgICAgICAgICB0b2tlbkluZGV4Kys7XG4gICAgICAgICAgaWYgKCFidWZmZXIudG9rZW5zX21lcmdlW3Rva2VuSW5kZXggKyAxXSkgZXhpdFdoaWxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBfbGluZTtcbiAgICAgICAgbGV0IGJhY2tzbGFzaENvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLnN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSB0b2tlbi5zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIGJhY2tzbGFzaENvdW50ID0gYmFja3NsYXNoQ291bnQgPiAwID8gYmFja3NsYXNoQ291bnQgKyAxIDogMTtlbHNlIHtcbiAgICAgICAgICAgIGlmIChiYWNrc2xhc2hDb3VudCAlIDIgIT09IDAgfHwgYmFja3NsYXNoQ291bnQgPT09IDApIGlmICgnXFwnXCJiZm5ydCcuaW5kZXhPZihjaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3IodG9rZW5JbmRleCwgZm9ybWF0KGxvY2FsZS5pbnZhbGlkVG9rZW4udW5leHBlY3RlZCwge1xuICAgICAgICAgICAgICAgIHRva2VuOiAnXFxcXCdcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFja3NsYXNoQ291bnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IpIHNldEVycm9yKHRva2VuSW5kZXgsIGZvcm1hdChsb2NhbGUuaW52YWxpZFRva2VuLnVuZXhwZWN0ZWQsIHtcbiAgICAgICAgICB0b2tlbjogdG9rZW4uc3RyaW5nXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGxldCBfbGluZSA9IDEsXG4gICAgICAgICAgX2RlcHRoID0gMDtcblxuICAgICAgZnVuY3Rpb24gbmV3SW5kZW50KCkge1xuICAgICAgICB2YXIgc3BhY2UgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kZXB0aCAqIDI7IGkrKykgc3BhY2UucHVzaCgnJm5ic3A7Jyk7XG5cbiAgICAgICAgcmV0dXJuIHNwYWNlLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXdMaW5lQnJlYWsoYnlQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgX2xpbmUrKztcblxuICAgICAgICBpZiAoX2RlcHRoID4gMCB8fCBieVBhc3MpIHtcbiAgICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXdMaW5lQnJlYWtBbmRJbmRlbnQoYnlQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVCcmVhayhieVBhc3MpICsgbmV3SW5kZW50KCk7XG4gICAgICB9XG5cbiAgICAgIDtcbiAgICAgIGlmICghZXJyb3IpIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGJ1ZmZlci50b2tlbnNfbWVyZ2VbaV0sXG4gICAgICAgICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZyxcbiAgICAgICAgICAgICAgdHlwZSA9IHRva2VuLnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdwcmltaXRpdmUnOlxuICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGJ1ZmZlci5tYXJrdXAgKz0gKGZvbGxvd3NTeW1ib2woaSwgWycsJywgJ1snXSkgPyBuZXdMaW5lQnJlYWtBbmRJbmRlbnQoKSA6ICcnKSArIG5ld1NwYW4oaSwgdG9rZW4sIF9kZXB0aCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgICBidWZmZXIubWFya3VwICs9IG5ld0xpbmVCcmVha0FuZEluZGVudCgpICsgbmV3U3BhbihpLCB0b2tlbiwgX2RlcHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY29sb24nOlxuICAgICAgICAgICAgYnVmZmVyLm1hcmt1cCArPSBuZXdTcGFuKGksIHRva2VuLCBfZGVwdGgpICsgJyZuYnNwOyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgYnVmZmVyLm1hcmt1cCArPSAoIWZvbGxvd3NTeW1ib2woaSwgWyc6J10pID8gbmV3TGluZUJyZWFrQW5kSW5kZW50KCkgOiAnJykgKyBuZXdTcGFuKGksIHRva2VuLCBfZGVwdGgpO1xuICAgICAgICAgICAgICAgIF9kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICBfZGVwdGgtLTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzbGFzdFRva2VuID0gaSA9PT0gYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICAgIF9hZGp1c3RtZW50ID0gaSA+IDAgPyBbJ1snLCAneyddLmluZGV4T2YoYnVmZmVyLnRva2Vuc19tZXJnZVtpIC0gMV0uc3RyaW5nKSA+IC0xID8gJycgOiBuZXdMaW5lQnJlYWtBbmRJbmRlbnQoaXNsYXN0VG9rZW4pIDogJyc7XG5cbiAgICAgICAgICAgICAgICBidWZmZXIubWFya3VwICs9IF9hZGp1c3RtZW50ICsgbmV3U3BhbihpLCB0b2tlbiwgX2RlcHRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgICAgICBidWZmZXIubWFya3VwICs9IG5ld1NwYW4oaSwgdG9rZW4sIF9kZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBsZXQgX2xpbmVfZmFsbGJhY2sgPSAxO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvdW50Q2FycmlnZVJldHVybihzdHJpbmcpIHtcbiAgICAgICAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChbJ1xcbicsICdcXHInXS5pbmRleE9mKHN0cmluZ1tpXSkgPiAtMSkgY291bnQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZSA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIudG9rZW5zX21lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBidWZmZXIudG9rZW5zX21lcmdlW2ldLFxuICAgICAgICAgICAgICAgIHR5cGUgPSB0b2tlbi50eXBlLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHRva2VuLnN0cmluZztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xpbmVicmVhaycpIF9saW5lKys7XG4gICAgICAgICAgYnVmZmVyLm1hcmt1cCArPSBuZXdTcGFuKGksIHRva2VuLCBfZGVwdGgpO1xuICAgICAgICAgIF9saW5lX2ZhbGxiYWNrICs9IGNvdW50Q2FycmlnZVJldHVybihzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmUrKztcbiAgICAgICAgX2xpbmVfZmFsbGJhY2srKztcbiAgICAgICAgaWYgKF9saW5lIDwgX2xpbmVfZmFsbGJhY2spIF9saW5lID0gX2xpbmVfZmFsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnRva2Vuc19tZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSBidWZmZXIudG9rZW5zX21lcmdlW2ldO1xuICAgICAgICBidWZmZXIuaW5kZW50ZWQgKz0gdG9rZW4uc3RyaW5nO1xuICAgICAgICBpZiAoWydzcGFjZScsICdsaW5lYnJlYWsnXS5pbmRleE9mKHRva2VuLnR5cGUpID09PSAtMSkgYnVmZmVyLnRva2Vuc19wbGFpblRleHQgKz0gdG9rZW4uc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIHt9LnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnbW9kaWZ5RXJyb3JUZXh0JyBpbiB0aGlzLnByb3BzKSBpZiAoaXNGdW5jdGlvbih0aGlzLnByb3BzLm1vZGlmeUVycm9yVGV4dCkpIGVycm9yLnJlYXNvbiA9IHRoaXMucHJvcHMubW9kaWZ5RXJyb3JUZXh0KGVycm9yLnJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuczogYnVmZmVyLnRva2Vuc19tZXJnZSxcbiAgICAgICAgbm9TcGFjZXM6IGJ1ZmZlci50b2tlbnNfcGxhaW5UZXh0LFxuICAgICAgICBpbmRlbnRlZDogYnVmZmVyLmluZGVudGVkLFxuICAgICAgICBqc29uOiBidWZmZXIuanNvbixcbiAgICAgICAganNPYmplY3Q6IGJ1ZmZlci5qc09iamVjdCxcbiAgICAgICAgbWFya3VwOiBidWZmZXIubWFya3VwLFxuICAgICAgICBsaW5lczogX2xpbmUsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICA7XG4gICAgLyoqXHJcbiAgICAgKiAgICAgSlMgT0JKRUNUUyB8fCBQTEFDRUhPTERFUlxyXG4gICAgICovXG5cbiAgICBpZiAoISgnbm9kZVR5cGUnIGluIHNvbWV0aGluZykpIHtcbiAgICAgIGxldCBidWZmZXIgPSB7XG4gICAgICAgIGlucHV0VGV4dDogSlNPTi5zdHJpbmdpZnkoc29tZXRoaW5nKSxcbiAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgIGN1cnJlbnRDaGFyOiAnJyxcbiAgICAgICAgdG9rZW5QcmltYXJ5OiAnJyxcbiAgICAgICAgdG9rZW5TZWNvbmRhcnk6ICcnLFxuICAgICAgICBicmFja2V0czogW10sXG4gICAgICAgIGlzVmFsdWU6IGZhbHNlLFxuICAgICAgICBzdHJpbmdPcGVuOiBmYWxzZSxcbiAgICAgICAgc3RyaW5nU3RhcnQ6IDAsXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGVzY2FwZV9jaGFyYWN0ZXIoKSB7XG4gICAgICAgIGlmIChidWZmZXIuY3VycmVudENoYXIgIT09ICdcXFxcJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXh0cmFjdChzdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgcG9zaXRpb24pICsgc3RyaW5nLnNsaWNlKHBvc2l0aW9uICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGVybWluZV9zdHJpbmcoKSB7XG4gICAgICAgIGlmICgnXFwnXCInLmluZGV4T2YoYnVmZmVyLmN1cnJlbnRDaGFyKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoIWJ1ZmZlci5zdHJpbmdPcGVuKSB7XG4gICAgICAgICAgYWRkX3Rva2VuU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgYnVmZmVyLnN0cmluZ1N0YXJ0ID0gYnVmZmVyLnBvc2l0aW9uO1xuICAgICAgICAgIGJ1ZmZlci5zdHJpbmdPcGVuID0gYnVmZmVyLmN1cnJlbnRDaGFyO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmZlci5zdHJpbmdPcGVuID09PSBidWZmZXIuY3VycmVudENoYXIpIHtcbiAgICAgICAgICBhZGRfdG9rZW5TZWNvbmRhcnkoKTtcbiAgICAgICAgICBjb25zdCBzdHJpbmdUb2tlbiA9IGJ1ZmZlci5pbnB1dFRleHQuc3Vic3RyaW5nKGJ1ZmZlci5zdHJpbmdTdGFydCwgYnVmZmVyLnBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgYWRkX3Rva2VuUHJpbWFyeShzdHJpbmdUb2tlbik7XG4gICAgICAgICAgYnVmZmVyLnN0cmluZ09wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lX3ZhbHVlKCkge1xuICAgICAgICBpZiAoJzose31bXScuaW5kZXhPZihidWZmZXIuY3VycmVudENoYXIpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYnVmZmVyLnN0cmluZ09wZW4pIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWRkX3Rva2VuU2Vjb25kYXJ5KCk7XG4gICAgICAgIGFkZF90b2tlblByaW1hcnkoYnVmZmVyLmN1cnJlbnRDaGFyKTtcblxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlci5jdXJyZW50Q2hhcikge1xuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgYnVmZmVyLmlzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgYnVmZmVyLmJyYWNrZXRzLnB1c2goYnVmZmVyLmN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICBidWZmZXIuYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIuY3VycmVudENoYXIgIT09ICc6JykgYnVmZmVyLmlzVmFsdWUgPSBidWZmZXIuYnJhY2tldHNbYnVmZmVyLmJyYWNrZXRzLmxlbmd0aCAtIDFdID09PSAnWyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRfdG9rZW5TZWNvbmRhcnkoKSB7XG4gICAgICAgIGlmIChidWZmZXIudG9rZW5TZWNvbmRhcnkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJ1ZmZlci50b2tlbnMucHVzaChidWZmZXIudG9rZW5TZWNvbmRhcnkpO1xuICAgICAgICBidWZmZXIudG9rZW5TZWNvbmRhcnkgPSAnJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZF90b2tlblByaW1hcnkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBidWZmZXIudG9rZW5zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuaW5wdXRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlci5wb3NpdGlvbiA9IGk7XG4gICAgICAgIGJ1ZmZlci5jdXJyZW50Q2hhciA9IGJ1ZmZlci5pbnB1dFRleHQuY2hhckF0KGJ1ZmZlci5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGEgPSBkZXRlcm1pbmVfdmFsdWUoKSxcbiAgICAgICAgICAgICAgYiA9IGRldGVybWluZV9zdHJpbmcoKSxcbiAgICAgICAgICAgICAgYyA9IGVzY2FwZV9jaGFyYWN0ZXIoKTtcbiAgICAgICAgaWYgKCFhICYmICFiICYmICFjKSBpZiAoIWJ1ZmZlci5zdHJpbmdPcGVuKSBidWZmZXIudG9rZW5TZWNvbmRhcnkgKz0gYnVmZmVyLmN1cnJlbnRDaGFyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYnVmZmVyMiA9IHtcbiAgICAgICAgYnJhY2tldHM6IFtdLFxuICAgICAgICBpc1ZhbHVlOiBmYWxzZSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcjIudG9rZW5zID0gYnVmZmVyLnRva2Vucy5tYXAodG9rZW4gPT4ge1xuICAgICAgICBsZXQgdHlwZSA9ICcnLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgdHlwZSA9ICdzeW1ib2wnO1xuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW47XG4gICAgICAgICAgICB2YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgYnVmZmVyMi5icmFja2V0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGJ1ZmZlcjIuaXNWYWx1ZSA9IGJ1ZmZlcjIuYnJhY2tldHNbYnVmZmVyMi5icmFja2V0cy5sZW5ndGggLSAxXSA9PT0gJ1snO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHR5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGJ1ZmZlcjIuYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICBidWZmZXIyLmlzVmFsdWUgPSBidWZmZXIyLmJyYWNrZXRzW2J1ZmZlcjIuYnJhY2tldHMubGVuZ3RoIC0gMV0gPT09ICdbJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHR5cGUgPSAncHJpbWl0aXZlJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgdHlwZSA9ICdwcmltaXRpdmUnO1xuICAgICAgICAgICAgc3RyaW5nID0gdG9rZW47XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgIHR5cGUgPSAncHJpbWl0aXZlJztcbiAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICB0eXBlID0gJ3ByaW1pdGl2ZSc7XG4gICAgICAgICAgICBzdHJpbmcgPSB0b2tlbjtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnN0IEMgPSB0b2tlbi5jaGFyQXQoMCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwUXVvdGVzRnJvbUtleSh0ZXh0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgIGlmIChbJ1wiXCInLCBcIicnXCJdLmluZGV4T2YodGV4dCkgPiAtMSkgcmV0dXJuIFwiJydcIjtcbiAgICAgICAgICAgICAgbGV0IHdyYXBwZWRJblF1b3RlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFt0ZXh0LmNoYXJBdCgwKSwgdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKV0uaW5kZXhPZihbJ1wiJywgXCInXCJdW2ldKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3cmFwcGVkSW5RdW90ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHdyYXBwZWRJblF1b3RlcyAmJiB0ZXh0Lmxlbmd0aCA+PSAyKSB0ZXh0ID0gdGV4dC5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgbm9uQWxwaGFOdW1lcmljID0gdGV4dC5yZXBsYWNlKC9cXHcvZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYU51bWVyaWMgPSB0ZXh0LnJlcGxhY2UoL1xcVysvZywgJycpLFxuICAgICAgICAgICAgICAgICAgICBtYXlSZW1vdmVRdW90ZXMgPSAoKG5vbkFscGhhTnVtZXJpYywgdGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXJBbmRMZXR0ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGlmIChpc05hTih0ZXh0LmNoYXJBdChpKSkpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odGV4dC5jaGFyQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlckFuZExldHRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAhKG5vbkFscGhhTnVtZXJpYy5sZW5ndGggPiAwIHx8IG51bWJlckFuZExldHRlcik7XG4gICAgICAgICAgICAgIH0pKG5vbkFscGhhTnVtZXJpYywgdGV4dCksXG4gICAgICAgICAgICAgICAgICAgIGhhc1F1b3RlcyA9IChzdHJpbmcgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoW1wiJ1wiLCAnXCInXS5pbmRleE9mKHN0cmluZy5jaGFyQXQoaSkpID4gLTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSkobm9uQWxwaGFOdW1lcmljKTtcblxuICAgICAgICAgICAgICBpZiAoaGFzUXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1RleHQgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyTGlzdCA9IHRleHQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNoYXJMaXN0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IGNoYXIgPSBjaGFyTGlzdFtpaV07XG4gICAgICAgICAgICAgICAgICBpZiAoW1wiJ1wiLCAnXCInXS5pbmRleE9mKGNoYXIpID4gLTEpIGNoYXIgPSAnXFxcXCcgKyBjaGFyO1xuICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXlSZW1vdmVRdW90ZXMpIHJldHVybiBcIidcIiArIHRleHQgKyBcIidcIjtlbHNlIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ1xcJ1wiJy5pbmRleE9mKEMpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcjIuaXNWYWx1ZSkgdHlwZSA9ICdzdHJpbmcnO2Vsc2UgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2tleScpIHN0cmluZyA9IHN0cmlwUXVvdGVzRnJvbUtleSh0b2tlbik7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhckxpc3QyID0gdG9rZW4uc2xpY2UoMSwgLTEpLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBjaGFyTGlzdDIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJMaXN0MltpaV07XG4gICAgICAgICAgICAgICAgICBpZiAoJ1xcJ1xcXCInLmluZGV4T2YoY2hhcikgPiAtMSkgY2hhciA9ICdcXFxcJyArIGNoYXI7XG4gICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgICAgICAgICAgICB0eXBlID0gJ251bWJlcic7XG4gICAgICAgICAgICAgIHN0cmluZyA9IHRva2VuO1xuICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcih0b2tlbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkgaWYgKCFidWZmZXIyLmlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICBzdHJpbmcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcgJykgPiAtMSkgc3RyaW5nID0gXCInXCIgKyBzdHJpbmcgKyBcIidcIjtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkZXB0aDogYnVmZmVyMi5icmFja2V0cy5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGNsZWFuID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyMi50b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRva2VuID0gYnVmZmVyMi50b2tlbnNbaV07XG4gICAgICAgIGNsZWFuICs9IHRva2VuLnN0cmluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5kZW50KG51bWJlcikge1xuICAgICAgICB2YXIgc3BhY2UgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlciAqIDI7IGkrKykgc3BhY2UucHVzaCgnICcpO1xuXG4gICAgICAgIHJldHVybiAobnVtYmVyID4gMCA/ICdcXG4nIDogJycpICsgc3BhY2Uuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIDtcbiAgICAgIGxldCBpbmRlbnRhdGlvbiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlcjIudG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4uc3RyaW5nKSB7XG4gICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSBpIDwgYnVmZmVyMi50b2tlbnMubGVuZ3RoIC0gMSAtIDEgPyBidWZmZXIyLnRva2Vuc1tpICsgMV0gOiAnJztcbiAgICAgICAgICAgIGlmICgnfV0nLmluZGV4T2YobmV4dFRva2VuLnN0cmluZykgPT09IC0xKSBpbmRlbnRhdGlvbiArPSB0b2tlbi5zdHJpbmcgKyBpbmRlbnQodG9rZW4uZGVwdGgpO2Vsc2UgaW5kZW50YXRpb24gKz0gdG9rZW4uc3RyaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbiA9IGkgPiAwID8gYnVmZmVyMi50b2tlbnNbaSAtIDFdIDogJyc7XG4gICAgICAgICAgICBpZiAoJ1t7Jy5pbmRleE9mKHByZXZUb2tlbi5zdHJpbmcpID09PSAtMSkgaW5kZW50YXRpb24gKz0gaW5kZW50KHRva2VuLmRlcHRoKSArIHRva2VuLnN0cmluZztlbHNlIGluZGVudGF0aW9uICs9IHRva2VuLnN0cmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB0b2tlbi5zdHJpbmcgKyAnICc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gdG9rZW4uc3RyaW5nICsgaW5kZW50KHRva2VuLmRlcHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHRva2VuLnN0cmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW5lcyA9IDE7XG5cbiAgICAgIGZ1bmN0aW9uIGluZGVudElJKG51bWJlcikge1xuICAgICAgICB2YXIgc3BhY2UgPSBbXTtcbiAgICAgICAgaWYgKG51bWJlciA+IDApIGxpbmVzKys7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXIgKiAyOyBpKyspIHNwYWNlLnB1c2goJyZuYnNwOycpO1xuXG4gICAgICAgIHJldHVybiAobnVtYmVyID4gMCA/ICc8YnI+JyA6ICcnKSArIHNwYWNlLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICA7XG4gICAgICBsZXQgbWFya3VwID0gJyc7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBidWZmZXIyLnRva2Vucy5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IGJ1ZmZlcjIudG9rZW5zW2ldO1xuICAgICAgICBsZXQgc3BhbiA9IG5ld1NwYW4oaSwgdG9rZW4sIHRva2VuLmRlcHRoKTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnN0cmluZykge1xuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gaSA8IGJ1ZmZlcjIudG9rZW5zLmxlbmd0aCAtIDEgLSAxID8gYnVmZmVyMi50b2tlbnNbaSArIDFdIDogJyc7XG4gICAgICAgICAgICBpZiAoJ31dJy5pbmRleE9mKG5leHRUb2tlbi5zdHJpbmcpID09PSAtMSkgbWFya3VwICs9IHNwYW4gKyBpbmRlbnRJSSh0b2tlbi5kZXB0aCk7ZWxzZSBtYXJrdXAgKz0gc3BhbjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICBjb25zdCBwcmV2VG9rZW4gPSBpID4gMCA/IGJ1ZmZlcjIudG9rZW5zW2kgLSAxXSA6ICcnO1xuICAgICAgICAgICAgaWYgKCdbeycuaW5kZXhPZihwcmV2VG9rZW4uc3RyaW5nKSA9PT0gLTEpIG1hcmt1cCArPSBpbmRlbnRJSSh0b2tlbi5kZXB0aCkgKyAobGFzdEluZGV4ID09PSBpID8gJzxicj4nIDogJycpICsgc3BhbjtlbHNlIG1hcmt1cCArPSBzcGFuO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIG1hcmt1cCArPSBzcGFuICsgJyAnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIG1hcmt1cCArPSBzcGFuICsgaW5kZW50SUkodG9rZW4uZGVwdGgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWFya3VwICs9IHNwYW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lcyArPSAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5zOiBidWZmZXIyLnRva2VucyxcbiAgICAgICAgbm9TcGFjZXM6IGNsZWFuLFxuICAgICAgICBpbmRlbnRlZDogaW5kZW50YXRpb24sXG4gICAgICAgIGpzb246IEpTT04uc3RyaW5naWZ5KHNvbWV0aGluZyksXG4gICAgICAgIGpzT2JqZWN0OiBzb21ldGhpbmcsXG4gICAgICAgIG1hcmt1cDogbWFya3VwLFxuICAgICAgICBsaW5lczogbGluZXNcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSlNPTklucHV0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/en.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/locale/en.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  format: \"{reason} at line {line}\",\n  symbols: {\n    colon: \"colon\",\n    // :\n    comma: \"comma\",\n    // ,  ،  、\n    semicolon: \"semicolon\",\n    // ;\n    slash: \"slash\",\n    // /  relevant for comment syntax support\n    backslash: \"backslash\",\n    // \\  relevant for escaping character\n    brackets: {\n      round: \"round brackets\",\n      // ( )\n      square: \"square brackets\",\n      // [ ]\n      curly: \"curly brackets\",\n      // { }\n      angle: \"angle brackets\" // < >\n\n    },\n    period: \"period\",\n    // . Also known as full point, full stop, or dot\n    quotes: {\n      single: \"single quote\",\n      // '\n      double: \"double quote\",\n      // \"\n      grave: \"grave accent\" // ` used on Javascript ES6 Syntax for String Templates\n\n    },\n    space: \"space\",\n    //       \n    ampersand: \"ampersand\",\n    //\t&\n    asterisk: \"asterisk\",\n    //\t*  relevant for some comment sytanx\n    at: \"at sign\",\n    //\t@  multiple uses in other coding languages including certain data types\n    equals: \"equals sign\",\n    //\t=\n    hash: \"hash\",\n    //\t#\n    percent: \"percent\",\n    //\t%\n    plus: \"plus\",\n    //\t+\n    minus: \"minus\",\n    //\t−\n    dash: \"dash\",\n    //\t−\n    hyphen: \"hyphen\",\n    //\t−\n    tilde: \"tilde\",\n    //\t~\n    underscore: \"underscore\",\n    //\t_\n    bar: \"vertical bar\" //\t|\n\n  },\n  types: {\n    key: \"key\",\n    value: \"value\",\n    number: \"number\",\n    string: \"string\",\n    primitive: \"primitive\",\n    boolean: \"boolean\",\n    character: \"character\",\n    integer: \"integer\",\n    array: \"array\",\n    float: \"float\" //... Reference: https://en.wikipedia.org/wiki/List_of_data_structures\n\n  },\n  invalidToken: {\n    tokenSequence: {\n      prohibited: \"'{firstToken}' token cannot be followed by '{secondToken}' token(s)\",\n      permitted: \"'{firstToken}' token can only be followed by '{secondToken}' token(s)\"\n    },\n    termSequence: {\n      prohibited: \"A {firstTerm} cannot be followed by a {secondTerm}\",\n      permitted: \"A {firstTerm} can only be followed by a {secondTerm}\"\n    },\n    double: \"'{token}' token cannot be followed by another '{token}' token\",\n    useInstead: \"'{badToken}' token is not accepted. Use '{goodToken}' instead\",\n    unexpected: \"Unexpected '{token}' token found\"\n  },\n  brace: {\n    curly: {\n      missingOpen: \"Missing '{' open curly brace\",\n      missingClose: \"Open '{' curly brace is missing closing '}' curly brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '{}' curly braces\"\n    },\n    square: {\n      missingOpen: \"Missing '[' open square brace\",\n      missingClose: \"Open '[' square brace is missing closing ']' square brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '[]' square braces\"\n    }\n  },\n  string: {\n    missingOpen: \"Missing/invalid opening string '{quote}' token\",\n    missingClose: \"Missing/invalid closing string '{quote}' token\",\n    mustBeWrappedByQuotes: \"Strings must be wrapped by quotes\",\n    nonAlphanumeric: \"Non-alphanumeric token '{token}' is not allowed outside string notation\",\n    unexpectedKey: \"Unexpected key found at string position\"\n  },\n  key: {\n    numberAndLetterMissingQuotes: \"Key beginning with number and containing letters must be wrapped by quotes\",\n    spaceMissingQuotes: \"Key containing space must be wrapped by quotes\",\n    unexpectedString: \"Unexpected string found at key position\"\n  },\n  noTrailingOrLeadingComma: \"Trailing or leading commas in arrays and objects are not permitted\"\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2xvY2FsZS9lbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWU7QUFDZixZQUFZLFFBQVEsU0FBUyxLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVyxnQ0FBZ0MsWUFBWTtBQUM1RSxvQkFBb0IsV0FBVyxrQ0FBa0MsWUFBWTtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsV0FBVyx5QkFBeUIsV0FBVztBQUNyRSxxQkFBcUIsV0FBVywyQkFBMkIsV0FBVztBQUN0RSxLQUFLO0FBQ0wsZUFBZSxNQUFNLHdDQUF3QyxNQUFNO0FBQ25FLG1CQUFtQixTQUFTLCtCQUErQixVQUFVO0FBQ3JFLDhCQUE4QixNQUFNO0FBQ3BDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRCQUE0QixtQ0FBbUM7QUFDL0QscUJBQXFCLE1BQU0sZ0NBQWdDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pELG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2xvY2FsZS9lbi5qcz9kOTg5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgZm9ybWF0OiBcIntyZWFzb259IGF0IGxpbmUge2xpbmV9XCIsXG4gIHN5bWJvbHM6IHtcbiAgICBjb2xvbjogXCJjb2xvblwiLFxuICAgIC8vIDpcbiAgICBjb21tYTogXCJjb21tYVwiLFxuICAgIC8vICwgINiMICDjgIFcbiAgICBzZW1pY29sb246IFwic2VtaWNvbG9uXCIsXG4gICAgLy8gO1xuICAgIHNsYXNoOiBcInNsYXNoXCIsXG4gICAgLy8gLyAgcmVsZXZhbnQgZm9yIGNvbW1lbnQgc3ludGF4IHN1cHBvcnRcbiAgICBiYWNrc2xhc2g6IFwiYmFja3NsYXNoXCIsXG4gICAgLy8gXFwgIHJlbGV2YW50IGZvciBlc2NhcGluZyBjaGFyYWN0ZXJcbiAgICBicmFja2V0czoge1xuICAgICAgcm91bmQ6IFwicm91bmQgYnJhY2tldHNcIixcbiAgICAgIC8vICggKVxuICAgICAgc3F1YXJlOiBcInNxdWFyZSBicmFja2V0c1wiLFxuICAgICAgLy8gWyBdXG4gICAgICBjdXJseTogXCJjdXJseSBicmFja2V0c1wiLFxuICAgICAgLy8geyB9XG4gICAgICBhbmdsZTogXCJhbmdsZSBicmFja2V0c1wiIC8vIDwgPlxuXG4gICAgfSxcbiAgICBwZXJpb2Q6IFwicGVyaW9kXCIsXG4gICAgLy8gLiBBbHNvIGtub3duIGFzIGZ1bGwgcG9pbnQsIGZ1bGwgc3RvcCwgb3IgZG90XG4gICAgcXVvdGVzOiB7XG4gICAgICBzaW5nbGU6IFwic2luZ2xlIHF1b3RlXCIsXG4gICAgICAvLyAnXG4gICAgICBkb3VibGU6IFwiZG91YmxlIHF1b3RlXCIsXG4gICAgICAvLyBcIlxuICAgICAgZ3JhdmU6IFwiZ3JhdmUgYWNjZW50XCIgLy8gYCB1c2VkIG9uIEphdmFzY3JpcHQgRVM2IFN5bnRheCBmb3IgU3RyaW5nIFRlbXBsYXRlc1xuXG4gICAgfSxcbiAgICBzcGFjZTogXCJzcGFjZVwiLFxuICAgIC8vICAg4oCCICDigINcbiAgICBhbXBlcnNhbmQ6IFwiYW1wZXJzYW5kXCIsXG4gICAgLy9cdCZcbiAgICBhc3RlcmlzazogXCJhc3Rlcmlza1wiLFxuICAgIC8vXHQqICByZWxldmFudCBmb3Igc29tZSBjb21tZW50IHN5dGFueFxuICAgIGF0OiBcImF0IHNpZ25cIixcbiAgICAvL1x0QCAgbXVsdGlwbGUgdXNlcyBpbiBvdGhlciBjb2RpbmcgbGFuZ3VhZ2VzIGluY2x1ZGluZyBjZXJ0YWluIGRhdGEgdHlwZXNcbiAgICBlcXVhbHM6IFwiZXF1YWxzIHNpZ25cIixcbiAgICAvL1x0PVxuICAgIGhhc2g6IFwiaGFzaFwiLFxuICAgIC8vXHQjXG4gICAgcGVyY2VudDogXCJwZXJjZW50XCIsXG4gICAgLy9cdCVcbiAgICBwbHVzOiBcInBsdXNcIixcbiAgICAvL1x0K1xuICAgIG1pbnVzOiBcIm1pbnVzXCIsXG4gICAgLy9cdOKIklxuICAgIGRhc2g6IFwiZGFzaFwiLFxuICAgIC8vXHTiiJJcbiAgICBoeXBoZW46IFwiaHlwaGVuXCIsXG4gICAgLy9cdOKIklxuICAgIHRpbGRlOiBcInRpbGRlXCIsXG4gICAgLy9cdH5cbiAgICB1bmRlcnNjb3JlOiBcInVuZGVyc2NvcmVcIixcbiAgICAvL1x0X1xuICAgIGJhcjogXCJ2ZXJ0aWNhbCBiYXJcIiAvL1x0fFxuXG4gIH0sXG4gIHR5cGVzOiB7XG4gICAga2V5OiBcImtleVwiLFxuICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgbnVtYmVyOiBcIm51bWJlclwiLFxuICAgIHN0cmluZzogXCJzdHJpbmdcIixcbiAgICBwcmltaXRpdmU6IFwicHJpbWl0aXZlXCIsXG4gICAgYm9vbGVhbjogXCJib29sZWFuXCIsXG4gICAgY2hhcmFjdGVyOiBcImNoYXJhY3RlclwiLFxuICAgIGludGVnZXI6IFwiaW50ZWdlclwiLFxuICAgIGFycmF5OiBcImFycmF5XCIsXG4gICAgZmxvYXQ6IFwiZmxvYXRcIiAvLy4uLiBSZWZlcmVuY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfZGF0YV9zdHJ1Y3R1cmVzXG5cbiAgfSxcbiAgaW52YWxpZFRva2VuOiB7XG4gICAgdG9rZW5TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCIne2ZpcnN0VG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCIsXG4gICAgICBwZXJtaXR0ZWQ6IFwiJ3tmaXJzdFRva2VufScgdG9rZW4gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCJcbiAgICB9LFxuICAgIHRlcm1TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCJBIHtmaXJzdFRlcm19IGNhbm5vdCBiZSBmb2xsb3dlZCBieSBhIHtzZWNvbmRUZXJtfVwiLFxuICAgICAgcGVybWl0dGVkOiBcIkEge2ZpcnN0VGVybX0gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYSB7c2Vjb25kVGVybX1cIlxuICAgIH0sXG4gICAgZG91YmxlOiBcIid7dG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYW5vdGhlciAne3Rva2VufScgdG9rZW5cIixcbiAgICB1c2VJbnN0ZWFkOiBcIid7YmFkVG9rZW59JyB0b2tlbiBpcyBub3QgYWNjZXB0ZWQuIFVzZSAne2dvb2RUb2tlbn0nIGluc3RlYWRcIixcbiAgICB1bmV4cGVjdGVkOiBcIlVuZXhwZWN0ZWQgJ3t0b2tlbn0nIHRva2VuIGZvdW5kXCJcbiAgfSxcbiAgYnJhY2U6IHtcbiAgICBjdXJseToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAneycgb3BlbiBjdXJseSBicmFjZVwiLFxuICAgICAgbWlzc2luZ0Nsb3NlOiBcIk9wZW4gJ3snIGN1cmx5IGJyYWNlIGlzIG1pc3NpbmcgY2xvc2luZyAnfScgY3VybHkgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICd7fScgY3VybHkgYnJhY2VzXCJcbiAgICB9LFxuICAgIHNxdWFyZToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAnWycgb3BlbiBzcXVhcmUgYnJhY2VcIixcbiAgICAgIG1pc3NpbmdDbG9zZTogXCJPcGVuICdbJyBzcXVhcmUgYnJhY2UgaXMgbWlzc2luZyBjbG9zaW5nICddJyBzcXVhcmUgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICdbXScgc3F1YXJlIGJyYWNlc1wiXG4gICAgfVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICBtaXNzaW5nT3BlbjogXCJNaXNzaW5nL2ludmFsaWQgb3BlbmluZyBzdHJpbmcgJ3txdW90ZX0nIHRva2VuXCIsXG4gICAgbWlzc2luZ0Nsb3NlOiBcIk1pc3NpbmcvaW52YWxpZCBjbG9zaW5nIHN0cmluZyAne3F1b3RlfScgdG9rZW5cIixcbiAgICBtdXN0QmVXcmFwcGVkQnlRdW90ZXM6IFwiU3RyaW5ncyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgbm9uQWxwaGFudW1lcmljOiBcIk5vbi1hbHBoYW51bWVyaWMgdG9rZW4gJ3t0b2tlbn0nIGlzIG5vdCBhbGxvd2VkIG91dHNpZGUgc3RyaW5nIG5vdGF0aW9uXCIsXG4gICAgdW5leHBlY3RlZEtleTogXCJVbmV4cGVjdGVkIGtleSBmb3VuZCBhdCBzdHJpbmcgcG9zaXRpb25cIlxuICB9LFxuICBrZXk6IHtcbiAgICBudW1iZXJBbmRMZXR0ZXJNaXNzaW5nUXVvdGVzOiBcIktleSBiZWdpbm5pbmcgd2l0aCBudW1iZXIgYW5kIGNvbnRhaW5pbmcgbGV0dGVycyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgc3BhY2VNaXNzaW5nUXVvdGVzOiBcIktleSBjb250YWluaW5nIHNwYWNlIG11c3QgYmUgd3JhcHBlZCBieSBxdW90ZXNcIixcbiAgICB1bmV4cGVjdGVkU3RyaW5nOiBcIlVuZXhwZWN0ZWQgc3RyaW5nIGZvdW5kIGF0IGtleSBwb3NpdGlvblwiXG4gIH0sXG4gIG5vVHJhaWxpbmdPckxlYWRpbmdDb21tYTogXCJUcmFpbGluZyBvciBsZWFkaW5nIGNvbW1hcyBpbiBhcnJheXMgYW5kIG9iamVjdHMgYXJlIG5vdCBwZXJtaXR0ZWRcIlxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/en.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/locale/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   format: function() { return /* binding */ format; }\n/* harmony export */ });\n// Allows us to pass arrays and numbers instead of just strings to the format function.\nconst stringify = arg => Array.isArray(arg) ? arg.join(\", \") : typeof arg === \"string\" ? arg : \"\" + arg; // Replaces a string with the values of an object. Google \"format unicorn\" on an explanation of how to use.\n\n\nconst format = (str, args) => args ? Object.keys(args).reduce((str, arg) => str.replace(new RegExp(`\\\\{${arg}\\\\}`, 'gi'), stringify(args[arg])), str) : str;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL2xvY2FsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSx5R0FBeUc7OztBQUd6Ryx1R0FBdUcsRUFBRSxJQUFJLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWpzb24tZWRpdG9yLWFqcm0vZXMvbG9jYWxlL2luZGV4LmpzP2FkNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWxsb3dzIHVzIHRvIHBhc3MgYXJyYXlzIGFuZCBudW1iZXJzIGluc3RlYWQgb2YganVzdCBzdHJpbmdzIHRvIHRoZSBmb3JtYXQgZnVuY3Rpb24uXG5jb25zdCBzdHJpbmdpZnkgPSBhcmcgPT4gQXJyYXkuaXNBcnJheShhcmcpID8gYXJnLmpvaW4oXCIsIFwiKSA6IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgPyBhcmcgOiBcIlwiICsgYXJnOyAvLyBSZXBsYWNlcyBhIHN0cmluZyB3aXRoIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBHb29nbGUgXCJmb3JtYXQgdW5pY29yblwiIG9uIGFuIGV4cGxhbmF0aW9uIG9mIGhvdyB0byB1c2UuXG5cblxuY29uc3QgZm9ybWF0ID0gKHN0ciwgYXJncykgPT4gYXJncyA/IE9iamVjdC5rZXlzKGFyZ3MpLnJlZHVjZSgoc3RyLCBhcmcpID0+IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFx7JHthcmd9XFxcXH1gLCAnZ2knKSwgc3RyaW5naWZ5KGFyZ3NbYXJnXSkpLCBzdHIpIDogc3RyO1xuXG5leHBvcnQgeyBmb3JtYXQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/locale/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * @author Andrew Redican <andrew.redican.mejia@gmail.com>\r\n */\n\n/**\r\n * Performs deep search on object tree, removes all properties with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\nfunction deepRemoveAll_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var paths = locateAll_Key(clonedIdentity, keyName, maxDepth);\n  if (paths === [] || paths === false) return clonedIdentity;\n  paths.forEach(path => {\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var ref = clonedIdentity;\n    if (!Array.isArray(path)) delete ref[path];\n\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (key in ref) {\n        if (i < path.length - 1) ref = ref[key];else delete ref[key];\n      } else break;\n    }\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, removes the first property with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepRemove_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var path = locate_Key(clonedIdentity, keyName, maxDepth);\n  if (path === false) return clonedIdentity;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var ref = clonedIdentity;\n  if (!Array.isArray(path)) delete ref[path];\n  path.forEach((key, i) => {\n    if (i < path.length - 1) ref = ref[key];else delete ref[key];\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, and renames the all matching keys\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKeys(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n\n  function _renameKeys(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (key === keyName) key = newKeyName;\n          Obj[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKeys(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Performs deep search on object tree, then renames the first matching key\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKey(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n  var applied = false;\n\n  function _renameKey(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (!applied) if (key === keyName) {\n            key = newKeyName;\n            applied = true;\n          }\n          Obj[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKey(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Creates a non-reference clone that is an exact copy to the identity provided.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @param {Optional Number} startDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepClone(identity, maxDepth = null, startDepth = null) {\n  var R = [];\n\n  function _deepClone(identity, maxDepth, startDepth, currentDepth = 0) {\n    let keys;\n\n    if (startDepth !== null ? currentDepth < startDepth : false) {\n      if (isIterable(identity)) {\n        keys = Object.keys(identity);\n        keys.forEach(key => {\n          _deepClone(identity[key], maxDepth, startDepth, currentDepth + 1);\n        });\n      }\n\n      return;\n    }\n\n    if (startDepth !== null ? currentDepth == startDepth : false) {\n      if (startDepth == 0) {\n        R = _deepClone(identity, maxDepth, null, currentDepth);\n        return;\n      }\n\n      if (isIterable(identity)) R.push(_deepClone(identity, maxDepth, startDepth, currentDepth + 1));\n      return;\n    }\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Arr[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Obj[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  if (startDepth === null) return _deepClone(identity, maxDepth, startDepth, 0);\n\n  _deepClone(identity, maxDepth, startDepth, 0);\n\n  return R;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, and returns a list of identities containing the matched instances. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} Identities\r\n */\n\n\nfunction deepFilter_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var paths = locateAll_Key(collection, keyName, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === false) return undefined;\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, returns the location of each match in a string array. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var R = [];\n\n  function _locateAll_Key(collection, keyName, xKey = '', path = '', maxDepth = null, currentDepth = 0) {\n    if (xKey === keyName) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll_Key(subcollection, keyName, key, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll_Key(collection, keyName, '', '', maxDepth);\n\n  R = R.map(path => {\n    if (getType(path) === 'boolean') return path;\n    if (path === '') return path;\n    path = path.split('.');\n    path.pop();\n    path = path.join('.');\n    return path;\n  });\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, and returns the first identity containing the match. If no match found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {Identity || undefined} identity\r\n */\n\n\nfunction deepGet_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var path = locate_Key(collection, keyName, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, will return the path of the first instance matched. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {String || false} Path\r\n */\n\n\nfunction locate_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  function _locate_Key(collection, keyName, path = '', maxDepth, currentDepth = 0) {\n    if (path === keyName) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate_Key(subcollection, keyName, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  var path = _locate_Key(collection, keyName, '', maxDepth, 0);\n\n  if (getType(path) === 'boolean') return path;\n  if (path === '') return path;\n  path = path.split('.');\n  path.pop();\n  path = path.join('.');\n  return path;\n}\n/**\r\n * Performs deep search for identity on collection to return the location's depth of the first match. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean}\r\n */\n\n\nfunction matchDepth(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return false;\n  if (path === '') return 0;\n  path = path.split('.');\n  return path.length;\n}\n/**\r\n * Walks through the entire object tree to return the maximum number of layers it contains.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n */\n\n\nfunction maxDepth(identity, maxLayer = null) {\n  let R = 0;\n\n  function _maxDepth(identity, maxLayer, currentDepth = 0) {\n    if (R < currentDepth) R = currentDepth;\n    if (maxLayer !== null) if (currentDepth >= maxLayer) return;\n\n    if (isIterable(identity)) {\n      var keys = Object.keys(identity);\n      keys.forEach(key => {\n        var subIdentity = identity[key];\n\n        _maxDepth(subIdentity, maxLayer, currentDepth + 1);\n      });\n    }\n  }\n\n  _maxDepth(identity, maxLayer);\n\n  return R;\n}\n/**\r\n * Performs deep search for identity on collection, returns the number of matches found.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Number} nthDepth\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns number of matches found.\r\n */\n\n\nfunction countMatches(collection, identity, nthDepth = null, maxDepth = null) {\n  var depth,\n      nthDepth_isNull = nthDepth === null,\n      maxDepth_isNull = maxDepth === null;\n  if (nthDepth_isNull && maxDepth_isNull) depth = null;else if (!nthDepth_isNull && !maxDepth_isNull) {\n    if (nthDepth < maxDepth) depth = nthDepth;else depth = maxDepth;\n  } else if (nthDepth) depth = nthDepth;else depth = maxDepth;\n  var paths = locateAll(collection, identity, depth);\n  if (paths === false) return 0;\n  if (nthDepth === null) return paths.length;\n\n  if (getType(nthDepth) === 'number') {\n    let count = 0;\n    paths.forEach(path => {\n      path = path.split('.');\n      if (path.length === nthDepth) count++;\n    });\n    return count;\n  }\n\n  return undefined;\n}\n/**\r\n* Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n* @param {Any} collection\r\n* @param {Any} identities\r\n* @param {Any} property\r\n* @param {Optional Number} maxDepth\r\n* @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n*/\n\n\nfunction onlyFalsy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundFalsy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundFalsy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundFalsy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isFalsy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundFalsy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundFalsy(collection, identity, maxDepth);\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Any} property\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyTruthy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundTruthy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundTruthy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundTruthy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isTruthy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundTruthy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundTruthy(collection, identity, maxDepth, 0);\n}\n/**\r\n * Validates if identity is equal to a property definition or contains a single property key.\r\n * @param {Property} identity\r\n * @return {String || boolean} If criteria matched will return property name as string, otherwise false\r\n */\n\n\nfunction singleProperty(identity) {\n  const propCount = length(identity);\n  if (propCount > 1) return false;\n  if (propCount === 1) return Object.keys(identity)[0];\n  if (propCount === 0) if (['string', 'number'].indexOf(getType(identity)) > -1) return identity;\n  return false;\n}\n/**\r\n * Determines if identity is non-falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isTruthy(identity) {\n  return !isFalsy(identity);\n}\n/**\r\n * Determines if identity is falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isFalsy(identity) {\n  if (falser(identity) === false) return true;\n  return false;\n}\n/**\r\n * Converts false-like values into actual boolean value of false\r\n * @param {Any} identity\r\n * @return {Any || boolean} Returns false is value is falsy, otherwise returns original value.\r\n */\n\n\nfunction falser(identity) {\n  if (isIterable(identity)) return identity;\n  if (['null', 'undefined'].indexOf(getType(identity)) > -1) return false;\n  if (['', 0, false].indexOf(identity) > -1) return false;\n  return identity;\n}\n/**\r\n * Check the length of the top-most depth of the identity\r\n * @param {Any} identity\r\n * @return {integer} Greater than or equal to 0.\r\n */\n\n\nfunction length(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return 0;\n  return Object.keys(identity).length;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that does meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that were not matched.\r\n */\n\n\nfunction onlyMissing(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (!exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (!exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (!exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyExisting(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the identity\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If a match is confirmed will return true, otherwise false\r\n */\n\n\nfunction exists(collection, identity, maxDepth = null, currentDepth = 0) {\n  if (identical(collection, identity)) return true;\n  if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n    const trimmed = trim(collection, Object.keys(identity));\n    if (identical(trimmed, identity)) return true;\n  }\n  if (maxDepth === null ? true : currentDepth < maxDepth) if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n    const key = keys[i],\n          subcollection = collection[key],\n          res = exists(subcollection, identity, maxDepth, currentDepth + 1);\n    if (res) return true;\n  }\n  return false;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, will return a list of identities containing the match. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} identities\r\n */\n\n\nfunction deepFilter(collection, identity, maxDepth = null) {\n  var paths = locateAll(collection, identity, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === '') return collection;\n    path = path.split('.');\n    if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, returns a string array containing the location of all matches. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll(collection, identity, maxDepth = null) {\n  var R = [];\n\n  function _locateAll(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) R[R.length] = path;\n    }\n    if (identical(collection, identity)) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll(subcollection, identity, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll(collection, identity, '', maxDepth, 0);\n\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the identity containing of the first instance matched. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {identity || undefined} identity\r\n */\n\n\nfunction deepGet(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') return collection;\n  path = path.split('.');\n  if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the path of the first instance matched as string. If no matches found, returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional number} maxDepth\r\n * @return {string || false} path\r\n */\n\n\nfunction locate(collection, identity, maxDepth = null) {\n  function _locate(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) return path;\n    }\n    if (identical(collection, identity)) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate(subcollection, identity, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  return _locate(collection, identity, '', maxDepth, 0);\n}\n/**\r\n * Trims an identity to only contain the specified properties.\r\n * @param {Any} identity\r\n * @param {Any} keyList\r\n * @return {Object or Array} Returns , otherwise false\r\n */\n\n\nfunction trim(identity, keyList) {\n  const identityType = getType(identity);\n  if (['array', 'object'].indexOf(identityType) === -1) return undefined;\n  const keyCount = keyList.length;\n  if (keyCount === 0) return undefined;\n  var newIdentity;\n\n  switch (identityType) {\n    case 'object':\n      newIdentity = {};\n      keyList.forEach(key => {\n        if (key in identity) newIdentity[key] = identity[key];\n      });\n      break;\n\n    case 'array':\n      newIdentity = [];\n      keyList.forEach(key => {\n        if (key in identity) newIdentity.push(identity[key]);\n      });\n      break;\n  }\n\n  return newIdentity;\n}\n/**\r\n * Check if identity contains all of the specified keys\r\n * @param {Any} identity\r\n * @param {Array} keyList\r\n * @return {boolean} true || false\r\n */\n\n\nfunction containsKeys(identity, keyList) {\n  const keyCount = keyList.length;\n  if (keyCount === 0 || !isIterable(identity)) return false;\n  const identitykeys = Object.keys(identity);\n  var result = true;\n\n  for (var i = 0; i < keyCount; i++) {\n    const key = '' + keyList[i];\n\n    if (identitykeys.indexOf(key) === -1) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check if identity has one or more keys to iterate\r\n * @param {Any} identity\r\n * @return {boolean} true || false\r\n */\n\n\nfunction isIterable(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return false;\n  if (Object.keys(identity).length === 0) return false;\n  return true;\n}\n/**\r\n * Compares two identities, will return either true if identical, otherwise false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction identical(identityA, identityB) {\n  const structureMatch = sameStructure(identityA, identityB);\n  if (structureMatch === false) return structureMatch;\n  if (['array', 'object'].indexOf(structureMatch) === -1) return identityA === identityB;\n  const Keys = Object.keys(identityA),\n        KeyCount = Keys.length;\n  var childMatch = true;\n\n  for (var i = 0; i < KeyCount; i++) {\n    const Key = Keys[i],\n          identicalMatch = identical(identityA[Key], identityB[Key]);\n\n    if (identicalMatch === false) {\n      childMatch = identicalMatch;\n      break;\n    }\n\n    ;\n  }\n\n  return childMatch;\n}\n/**\r\n * Compares data structure of two identities, will return either the dataType or true/false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {String || False} DataType as string for positive match, otherwise false\r\n */\n\n\nfunction sameStructure(identityA, identityB) {\n  const typeMatch = sameType(identityA, identityB);\n  if (typeMatch === false) return false;\n\n  if (['array', 'object'].indexOf(typeMatch) > -1) {\n    const AKeys = Object.keys(identityA),\n          BKeys = Object.keys(identityB),\n          AKeyCount = AKeys.length,\n          BKeyCount = BKeys.length;\n    if (!(AKeyCount === BKeyCount)) return false;\n    if (AKeyCount === 0) return true;\n\n    for (var i = 0; i < AKeyCount; i++) {\n      if (AKeys[i] !== BKeys[i]) return false;\n    }\n  }\n\n  return typeMatch;\n}\n/**\r\n * Compares data type of two identities, will dataType if true.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction sameType(identityA, identityB) {\n  const typeA = getType(identityA);\n  return typeA === getType(identityB) ? typeA : false;\n}\n/**\r\n * Gets data type; makes distintion between object, array, and null.\r\n * @param {Any} identity\r\n * @return {String} dataType\r\n */\n\n\nfunction getType(identity) {\n  if (identity === null) return 'null';\n  const it = typeof identity;\n  if (it === 'object') if (Array.isArray(identity)) return 'array';\n  return it;\n}\n\nvar mitsuketa = {\n  getType: function (identity) {\n    return getType(identity);\n  },\n  sameType: function (identityA, identityB) {\n    return sameType(identityA, identityB);\n  },\n  sameStructure: function (identityA, identityB) {\n    return sameStructure(identityA, identityB);\n  },\n  identical: function (identityA, identityB) {\n    return identical(identityA, identityB);\n  },\n  isIterable: function (identity) {\n    return isIterable(identity);\n  },\n  containsKeys: function (identity, keyList) {\n    return containsKeys(identity, keyList);\n  },\n  trim: function (identity, keyList) {\n    return trim(identity, keyList);\n  },\n  locate: function (collection, identity, maxDepth) {\n    return locate(collection, identity, maxDepth);\n  },\n  deepGet: function (collection, identity, maxDepth) {\n    return deepGet(collection, identity, maxDepth);\n  },\n  locateAll: function (collection, identity, maxDepth) {\n    return locateAll(collection, identity, maxDepth);\n  },\n  deepFilter: function (collection, identity, maxDepth) {\n    return deepFilter(collection, identity, maxDepth);\n  },\n  exists: function (collection, identity, maxDepth) {\n    return exists(collection, identity, maxDepth);\n  },\n  onlyExisting: function (collection, identities, maxDepth) {\n    return onlyExisting(collection, identities, maxDepth);\n  },\n  onlyMissing: function (collection, identities, maxDepth) {\n    return onlyMissing(collection, identities, maxDepth);\n  },\n  length: function (identity) {\n    return length(identity);\n  },\n  isFalsy: function (identity) {\n    return isFalsy(identity);\n  },\n  isTruthy: function (identity) {\n    return isTruthy(identity);\n  },\n  foundTruthy: function (collection, identity, maxDepth) {\n    return foundTruthy(collection, identity, maxDepth);\n  },\n  onlyTruthy: function (collection, identities, property, maxDepth) {\n    return onlyTruthy(collection, identities, property, maxDepth);\n  },\n  foundFalsy: function (collection, identity, maxDepth) {\n    return foundFalsy(collection, identity, maxDepth);\n  },\n  onlyFalsy: function (collection, identities, property, maxDepth) {\n    return onlyFalsy(collection, identities, property, maxDepth);\n  },\n  countMatches: function (collection, identity, nthDepth, maxDepth) {\n    return countMatches(collection, identity, nthDepth, maxDepth);\n  },\n  matchDepth: function (collection, identity, maxDepth) {\n    return matchDepth(collection, identity, maxDepth);\n  },\n  maxDepth: function (identity, maxLayer) {\n    return maxDepth(identity, maxLayer);\n  },\n  locate_Key: function (collection, keyName, maxDepth) {\n    return locate_Key(collection, keyName, maxDepth);\n  },\n  deepGet_Key: function (collection, keyName, maxDepth) {\n    return deepGet_Key(collection, keyName, maxDepth);\n  },\n  locateAll_Key: function (collection, keyName, maxDepth) {\n    return locateAll_Key(collection, keyName, maxDepth);\n  },\n  deepFilter_Key: function (collection, keyName, maxDepth) {\n    return deepFilter_Key(collection, keyName, maxDepth);\n  },\n  deepClone: function (identity, maxDepth, startDepth) {\n    return deepClone(identity, maxDepth, startDepth);\n  },\n  renameKey: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKey(identity, keyName, newKeyName, maxDepth);\n  },\n  renameKeys: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKeys(identity, keyName, newKeyName, maxDepth);\n  },\n  deepRemove_Key: function (identity, keyName, maxDepth) {\n    return deepRemove_Key(identity, keyName, maxDepth);\n  },\n  deepRemoveAll_Key: function (identity, keyName, maxDepth) {\n    return deepRemoveAll_Key(identity, keyName, maxDepth);\n  }\n};\nmodule.exports = exports = mitsuketa;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL21pdHN1a2V0YS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixZQUFZLEtBQUs7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixZQUFZLEtBQUs7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFX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QUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL21pdHN1a2V0YS9pbmRleC5qcz8zZjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAYXV0aG9yIEFuZHJldyBSZWRpY2FuIDxhbmRyZXcucmVkaWNhbi5tZWppYUBnbWFpbC5jb20+XHJcbiAqL1xuXG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gb2JqZWN0IHRyZWUsIHJlbW92ZXMgYWxsIHByb3BlcnRpZXMgd2l0aCBtYXRjaGluZyBrZXksIHJldHVybnMgYSBuZXcgaWRlbnRpdHkgd2l0aG91dCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBpZGVudGl0eVxyXG4gKi9cbmZ1bmN0aW9uIGRlZXBSZW1vdmVBbGxfS2V5KGlkZW50aXR5LCBrZXlOYW1lLCBtYXhEZXB0aCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChrZXlOYW1lID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgbGV0IGNsb25lZElkZW50aXR5ID0gZGVlcENsb25lKGlkZW50aXR5KTtcbiAgdmFyIHBhdGhzID0gbG9jYXRlQWxsX0tleShjbG9uZWRJZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aHMgPT09IFtdIHx8IHBhdGhzID09PSBmYWxzZSkgcmV0dXJuIGNsb25lZElkZW50aXR5O1xuICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgIGlmIChwYXRoID09PSAnJykgcGF0aCA9IGtleU5hbWU7ZWxzZSBwYXRoICs9ICcuJyArIGtleU5hbWU7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgcmVmID0gY2xvbmVkSWRlbnRpdHk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSBkZWxldGUgcmVmW3BhdGhdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXTtcblxuICAgICAgaWYgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKGkgPCBwYXRoLmxlbmd0aCAtIDEpIHJlZiA9IHJlZltrZXldO2Vsc2UgZGVsZXRlIHJlZltrZXldO1xuICAgICAgfSBlbHNlIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9uZWRJZGVudGl0eTtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBvYmplY3QgdHJlZSwgcmVtb3ZlcyB0aGUgZmlyc3QgcHJvcGVydHkgd2l0aCBtYXRjaGluZyBrZXksIHJldHVybnMgYSBuZXcgaWRlbnRpdHkgd2l0aG91dCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBpZGVudGl0eVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwUmVtb3ZlX0tleShpZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgaWYgKGdldFR5cGUoa2V5TmFtZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoa2V5TmFtZSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGxldCBjbG9uZWRJZGVudGl0eSA9IGRlZXBDbG9uZShpZGVudGl0eSk7XG4gIHZhciBwYXRoID0gbG9jYXRlX0tleShjbG9uZWRJZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aCA9PT0gZmFsc2UpIHJldHVybiBjbG9uZWRJZGVudGl0eTtcbiAgaWYgKHBhdGggPT09ICcnKSBwYXRoID0ga2V5TmFtZTtlbHNlIHBhdGggKz0gJy4nICsga2V5TmFtZTtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIHJlZiA9IGNsb25lZElkZW50aXR5O1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIGRlbGV0ZSByZWZbcGF0aF07XG4gIHBhdGguZm9yRWFjaCgoa2V5LCBpKSA9PiB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aCAtIDEpIHJlZiA9IHJlZltrZXldO2Vsc2UgZGVsZXRlIHJlZltrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lZElkZW50aXR5O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIG9iamVjdCB0cmVlLCBhbmQgcmVuYW1lcyB0aGUgYWxsIG1hdGNoaW5nIGtleXNcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlOYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdLZXlOYW1lXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBbnl9IGlkZW50aXR5XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmFtZUtleXMoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChnZXRUeXBlKG5ld0tleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAobmV3S2V5TmFtZSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gX3JlbmFtZUtleXMoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggPSAwKSB7XG4gICAgbGV0IGtleXM7XG5cbiAgICBzd2l0Y2ggKGdldFR5cGUoaWRlbnRpdHkpKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIHZhciBBcnIgPSBbXTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgIHN1YklkZW50aXR5ID0gaWRlbnRpdHlba2V5XTtcbiAgICAgICAgICBBcnJba2V5XSA9IF9yZW5hbWVLZXlzKHN1YklkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB2YXIgT2JqID0ge307XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxldCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgICBzdWJJZGVudGl0eSA9IGlkZW50aXR5W2tleV07XG4gICAgICAgICAgaWYgKG1heERlcHRoICE9PSBudWxsID8gY3VycmVudERlcHRoIDwgbWF4RGVwdGggOiB0cnVlKSBpZiAoa2V5ID09PSBrZXlOYW1lKSBrZXkgPSBuZXdLZXlOYW1lO1xuICAgICAgICAgIE9ialtrZXldID0gX3JlbmFtZUtleXMoc3ViSWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmo7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnJyArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gMCArIGlkZW50aXR5O1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKGlkZW50aXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yZW5hbWVLZXlzKGlkZW50aXR5LCBrZXlOYW1lLCBuZXdLZXlOYW1lLCBtYXhEZXB0aCwgMCk7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gb2JqZWN0IHRyZWUsIHRoZW4gcmVuYW1lcyB0aGUgZmlyc3QgbWF0Y2hpbmcga2V5XHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3S2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBpZGVudGl0eVxyXG4gKi9cblxuXG5mdW5jdGlvbiByZW5hbWVLZXkoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShrZXlOYW1lKSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChnZXRUeXBlKG5ld0tleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAobmV3S2V5TmFtZSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gIHZhciBhcHBsaWVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gX3JlbmFtZUtleShpZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICBsZXQga2V5cztcblxuICAgIHN3aXRjaCAoZ2V0VHlwZShpZGVudGl0eSkpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgdmFyIEFyciA9IFtdO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuICAgICAgICAgIEFycltrZXldID0gX3JlbmFtZUtleShzdWJJZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycjtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgdmFyIE9iaiA9IHt9O1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuICAgICAgICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCA/IGN1cnJlbnREZXB0aCA8IG1heERlcHRoIDogdHJ1ZSkgaWYgKCFhcHBsaWVkKSBpZiAoa2V5ID09PSBrZXlOYW1lKSB7XG4gICAgICAgICAgICBrZXkgPSBuZXdLZXlOYW1lO1xuICAgICAgICAgICAgYXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9ialtrZXldID0gX3JlbmFtZUtleShzdWJJZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iajtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuICcnICsgaWRlbnRpdHk7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiAwICsgaWRlbnRpdHk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAoaWRlbnRpdHkpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX3JlbmFtZUtleShpZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgsIDApO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBub24tcmVmZXJlbmNlIGNsb25lIHRoYXQgaXMgYW4gZXhhY3QgY29weSB0byB0aGUgaWRlbnRpdHkgcHJvdmlkZWQuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IHN0YXJ0RGVwdGhcclxuICogQHJldHVybiB7QW55fSBpZGVudGl0eVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwQ2xvbmUoaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCwgc3RhcnREZXB0aCA9IG51bGwpIHtcbiAgdmFyIFIgPSBbXTtcblxuICBmdW5jdGlvbiBfZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGxldCBrZXlzO1xuXG4gICAgaWYgKHN0YXJ0RGVwdGggIT09IG51bGwgPyBjdXJyZW50RGVwdGggPCBzdGFydERlcHRoIDogZmFsc2UpIHtcbiAgICAgIGlmIChpc0l0ZXJhYmxlKGlkZW50aXR5KSkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBfZGVlcENsb25lKGlkZW50aXR5W2tleV0sIG1heERlcHRoLCBzdGFydERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnREZXB0aCAhPT0gbnVsbCA/IGN1cnJlbnREZXB0aCA9PSBzdGFydERlcHRoIDogZmFsc2UpIHtcbiAgICAgIGlmIChzdGFydERlcHRoID09IDApIHtcbiAgICAgICAgUiA9IF9kZWVwQ2xvbmUoaWRlbnRpdHksIG1heERlcHRoLCBudWxsLCBjdXJyZW50RGVwdGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0l0ZXJhYmxlKGlkZW50aXR5KSkgUi5wdXNoKF9kZWVwQ2xvbmUoaWRlbnRpdHksIG1heERlcHRoLCBzdGFydERlcHRoLCBjdXJyZW50RGVwdGggKyAxKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZXRUeXBlKGlkZW50aXR5KSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICB2YXIgQXJyID0gW107XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eSk7XG4gICAgICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCA/IGN1cnJlbnREZXB0aCA8IG1heERlcHRoIDogdHJ1ZSkgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICAgICAgc3ViSWRlbnRpdHkgPSBpZGVudGl0eVtrZXldO1xuICAgICAgICAgIEFycltrZXldID0gX2RlZXBDbG9uZShzdWJJZGVudGl0eSwgbWF4RGVwdGgsIHN0YXJ0RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnI7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHZhciBPYmogPSB7fTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcbiAgICAgICAgaWYgKG1heERlcHRoICE9PSBudWxsID8gY3VycmVudERlcHRoIDwgbWF4RGVwdGggOiB0cnVlKSBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgICAgICBzdWJJZGVudGl0eSA9IGlkZW50aXR5W2tleV07XG4gICAgICAgICAgT2JqW2tleV0gPSBfZGVlcENsb25lKHN1YklkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iajtcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuICcnICsgaWRlbnRpdHk7XG5cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiAwICsgaWRlbnRpdHk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAoaWRlbnRpdHkpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREZXB0aCA9PT0gbnVsbCkgcmV0dXJuIF9kZWVwQ2xvbmUoaWRlbnRpdHksIG1heERlcHRoLCBzdGFydERlcHRoLCAwKTtcblxuICBfZGVlcENsb25lKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCwgMCk7XG5cbiAgcmV0dXJuIFI7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFsbCBtYXRjaGVzIHRvIHRoZSBrZXkgbmFtZSwgYW5kIHJldHVybnMgYSBsaXN0IG9mIGlkZW50aXRpZXMgY29udGFpbmluZyB0aGUgbWF0Y2hlZCBpbnN0YW5jZXMuIElmIG5vIG1hdGNoZXMgZm91bmQsIGl0IHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBrZXlOYW1lXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBcnJheSB8fCB1bmRlZmluZWR9IElkZW50aXRpZXNcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcEZpbHRlcl9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlmIChnZXRUeXBlKGtleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgcGF0aHMgPSBsb2NhdGVBbGxfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoKTtcbiAgaWYgKHBhdGhzID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgcmVzdWx0cyA9IHBhdGhzLm1hcChwYXRoID0+IHtcbiAgICBpZiAocGF0aCA9PT0gZmFsc2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHBhdGggPT09ICcnKSBwYXRoID0ga2V5TmFtZTtlbHNlIHBhdGggKz0gJy4nICsga2V5TmFtZTtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuIHJlc3VsdFtwYXRoXTtcbiAgICBwYXRoLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdFtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYWxsIG1hdGNoZXMgdG8gdGhlIGtleSBuYW1lLCByZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiBlYWNoIG1hdGNoIGluIGEgc3RyaW5nIGFycmF5LiBJZiBubyBtYXRjaGVzIGZvdW5kLCBpdCByZXR1cm5zIGBmYWxzZWAuXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBrZXlOYW1lXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBcnJheSB8fCBmYWxzZX0gUGF0aHNcclxuICovXG5cblxuZnVuY3Rpb24gbG9jYXRlQWxsX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCA9IG51bGwpIHtcbiAgaWYgKGdldFR5cGUoa2V5TmFtZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAoa2V5TmFtZSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gIHZhciBSID0gW107XG5cbiAgZnVuY3Rpb24gX2xvY2F0ZUFsbF9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgeEtleSA9ICcnLCBwYXRoID0gJycsIG1heERlcHRoID0gbnVsbCwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGlmICh4S2V5ID09PSBrZXlOYW1lKSBSW1IubGVuZ3RoXSA9IHBhdGg7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNJdGVyYWJsZShjb2xsZWN0aW9uKSkgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgc3ViY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25ba2V5XTtcblxuICAgICAgX2xvY2F0ZUFsbF9LZXkoc3ViY29sbGVjdGlvbiwga2V5TmFtZSwga2V5LCAocGF0aCA9PT0gJycgPyBwYXRoIDogcGF0aCArICcuJykgKyBrZXksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICB9XG4gIH1cblxuICBfbG9jYXRlQWxsX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCAnJywgJycsIG1heERlcHRoKTtcblxuICBSID0gUi5tYXAocGF0aCA9PiB7XG4gICAgaWYgKGdldFR5cGUocGF0aCkgPT09ICdib29sZWFuJykgcmV0dXJuIHBhdGg7XG4gICAgaWYgKHBhdGggPT09ICcnKSByZXR1cm4gcGF0aDtcbiAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHBhdGgucG9wKCk7XG4gICAgcGF0aCA9IHBhdGguam9pbignLicpO1xuICAgIHJldHVybiBwYXRoO1xuICB9KTtcbiAgcmV0dXJuIFIubGVuZ3RoID09PSAwID8gZmFsc2UgOiBSO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIG9uIGNvbGxlY3Rpb24gdG8gZmluZCBhIG1hdGNoIHRvIHRoZSBrZXkgbmFtZSwgYW5kIHJldHVybnMgdGhlIGZpcnN0IGlkZW50aXR5IGNvbnRhaW5pbmcgdGhlIG1hdGNoLiBJZiBubyBtYXRjaCBmb3VuZCwgaXQgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGtleU5hbWVcclxuICogQHBhcmFtIHtPcHRpb25hbCBudW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0lkZW50aXR5IHx8IHVuZGVmaW5lZH0gaWRlbnRpdHlcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcEdldF9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlmIChnZXRUeXBlKGtleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgcGF0aCA9IGxvY2F0ZV9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aCA9PT0gZmFsc2UpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChwYXRoID09PSAnJykgcGF0aCA9IGtleU5hbWU7ZWxzZSBwYXRoICs9ICcuJyArIGtleU5hbWU7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiByZXN1bHRbcGF0aF07XG4gIHBhdGguZm9yRWFjaChrZXkgPT4ge1xuICAgIHJlc3VsdCA9IHJlc3VsdFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYSBtYXRjaCB0byB0aGUga2V5IG5hbWUsIHdpbGwgcmV0dXJuIHRoZSBwYXRoIG9mIHRoZSBmaXJzdCBpbnN0YW5jZSBtYXRjaGVkLiBJZiBubyBtYXRjaCBmb3VuZCwgaXQgcmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0ga2V5TmFtZVxyXG4gKiBAcGFyYW0ge09wdGlvbmFsIG51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7U3RyaW5nIHx8IGZhbHNlfSBQYXRoXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2F0ZV9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlmIChnZXRUeXBlKGtleU5hbWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKGtleU5hbWUgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIF9sb2NhdGVfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIHBhdGggPSAnJywgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCA9IDApIHtcbiAgICBpZiAocGF0aCA9PT0ga2V5TmFtZSkgcmV0dXJuIHBhdGg7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNJdGVyYWJsZShjb2xsZWN0aW9uKSkgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLFxuICAgICAgICAgICAgc3ViY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25ba2V5XSxcbiAgICAgICAgICAgIHJlcyA9IF9sb2NhdGVfS2V5KHN1YmNvbGxlY3Rpb24sIGtleU5hbWUsIGtleSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHBhdGggPSBwYXRoID09PSAnJyA/IHBhdGggOiBwYXRoICsgJy4nO1xuICAgICAgICByZXN1bHQgPSBwYXRoICsgcmVzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBwYXRoID0gX2xvY2F0ZV9LZXkoY29sbGVjdGlvbiwga2V5TmFtZSwgJycsIG1heERlcHRoLCAwKTtcblxuICBpZiAoZ2V0VHlwZShwYXRoKSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGF0aDtcbiAgaWYgKHBhdGggPT09ICcnKSByZXR1cm4gcGF0aDtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcGF0aC5wb3AoKTtcbiAgcGF0aCA9IHBhdGguam9pbignLicpO1xuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBmb3IgaWRlbnRpdHkgb24gY29sbGVjdGlvbiB0byByZXR1cm4gdGhlIGxvY2F0aW9uJ3MgZGVwdGggb2YgdGhlIGZpcnN0IG1hdGNoLiBJZiBubyBtYXRjaCBmb3VuZCwgaXQgcmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1hdGNoRGVwdGgoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICB2YXIgcGF0aCA9IGxvY2F0ZShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKHBhdGggPT09ICcnKSByZXR1cm4gMDtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoO1xufVxuLyoqXHJcbiAqIFdhbGtzIHRocm91Z2ggdGhlIGVudGlyZSBvYmplY3QgdHJlZSB0byByZXR1cm4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxheWVycyBpdCBjb250YWlucy5cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXhEZXB0aChpZGVudGl0eSwgbWF4TGF5ZXIgPSBudWxsKSB7XG4gIGxldCBSID0gMDtcblxuICBmdW5jdGlvbiBfbWF4RGVwdGgoaWRlbnRpdHksIG1heExheWVyLCBjdXJyZW50RGVwdGggPSAwKSB7XG4gICAgaWYgKFIgPCBjdXJyZW50RGVwdGgpIFIgPSBjdXJyZW50RGVwdGg7XG4gICAgaWYgKG1heExheWVyICE9PSBudWxsKSBpZiAoY3VycmVudERlcHRoID49IG1heExheWVyKSByZXR1cm47XG5cbiAgICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHZhciBzdWJJZGVudGl0eSA9IGlkZW50aXR5W2tleV07XG5cbiAgICAgICAgX21heERlcHRoKHN1YklkZW50aXR5LCBtYXhMYXllciwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfbWF4RGVwdGgoaWRlbnRpdHksIG1heExheWVyKTtcblxuICByZXR1cm4gUjtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBmb3IgaWRlbnRpdHkgb24gY29sbGVjdGlvbiwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIG1hdGNoZXMgZm91bmQuXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnRoRGVwdGhcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FueX0gUmV0dXJucyBudW1iZXIgb2YgbWF0Y2hlcyBmb3VuZC5cclxuICovXG5cblxuZnVuY3Rpb24gY291bnRNYXRjaGVzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBudGhEZXB0aCA9IG51bGwsIG1heERlcHRoID0gbnVsbCkge1xuICB2YXIgZGVwdGgsXG4gICAgICBudGhEZXB0aF9pc051bGwgPSBudGhEZXB0aCA9PT0gbnVsbCxcbiAgICAgIG1heERlcHRoX2lzTnVsbCA9IG1heERlcHRoID09PSBudWxsO1xuICBpZiAobnRoRGVwdGhfaXNOdWxsICYmIG1heERlcHRoX2lzTnVsbCkgZGVwdGggPSBudWxsO2Vsc2UgaWYgKCFudGhEZXB0aF9pc051bGwgJiYgIW1heERlcHRoX2lzTnVsbCkge1xuICAgIGlmIChudGhEZXB0aCA8IG1heERlcHRoKSBkZXB0aCA9IG50aERlcHRoO2Vsc2UgZGVwdGggPSBtYXhEZXB0aDtcbiAgfSBlbHNlIGlmIChudGhEZXB0aCkgZGVwdGggPSBudGhEZXB0aDtlbHNlIGRlcHRoID0gbWF4RGVwdGg7XG4gIHZhciBwYXRocyA9IGxvY2F0ZUFsbChjb2xsZWN0aW9uLCBpZGVudGl0eSwgZGVwdGgpO1xuICBpZiAocGF0aHMgPT09IGZhbHNlKSByZXR1cm4gMDtcbiAgaWYgKG50aERlcHRoID09PSBudWxsKSByZXR1cm4gcGF0aHMubGVuZ3RoO1xuXG4gIGlmIChnZXRUeXBlKG50aERlcHRoKSA9PT0gJ251bWJlcicpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSBudGhEZXB0aCkgY291bnQrKztcbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXHJcbiogUGVyZm9ybXMgZGVlcCBzZWFyY2ggZm9yIGVhY2ggaWRlbnRpdHkgb24gY29sbGVjdGlvbiwgdG8gc2hvcnRlbiB0aGUgaWRlbnRpdGllcyB0byB0aG9zZSB0aGF0IG1lZXRzIHRoZSBtYXRjaCBjcml0ZXJpYVxyXG4qIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiogQHBhcmFtIHtBbnl9IGlkZW50aXRpZXNcclxuKiBAcGFyYW0ge0FueX0gcHJvcGVydHlcclxuKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuKiBAcmV0dXJuIHtBbnl9IFJldHVybnMgYSBjb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlICdpZGVudGl0aWVzJyBwYXJhbWV0ZXIgcHJvdmlkZWQgd2l0aCBvbmx5IHRoZSBpZGVudGl0aWVzIHRoYXQgbWF0Y2hlZC5cclxuKi9cblxuXG5mdW5jdGlvbiBvbmx5RmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ2FycmF5Jykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZGVudGl0aWVzLmZvckVhY2goaWRlbnRpdHkgPT4ge1xuICAgICAgY29uc3Qgc3ViQ29sbGVjdGlvbiA9IGRlZXBGaWx0ZXIoY29sbGVjdGlvbiwgaWRlbnRpdHkpO1xuICAgICAgaWYgKGlzVHJ1dGh5KHN1YkNvbGxlY3Rpb24pKSBpZiAoZm91bmRGYWxzeShzdWJDb2xsZWN0aW9uLCBwcm9wZXJ0eSwgbWF4RGVwdGgpKSByZXN1bHQucHVzaChpZGVudGl0eSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChnZXRUeXBlKGlkZW50aXRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBpZGVudGl0eSA9IGlkZW50aXRpZXNba2V5XSxcbiAgICAgICAgICAgIHN1YkNvbGxlY3Rpb24gPSBkZWVwRmlsdGVyKGNvbGxlY3Rpb24sIGlkZW50aXR5KTtcbiAgICAgIGlmIChpc1RydXRoeShzdWJDb2xsZWN0aW9uKSkgaWYgKGZvdW5kRmFsc3koc3ViQ29sbGVjdGlvbiwgcHJvcGVydHksIG1heERlcHRoKSkgcmVzdWx0W2tleV0gPSBpZGVudGl0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGZvdW5kRmFsc3koY29sbGVjdGlvbiwgcHJvcGVydHksIG1heERlcHRoKSkgcmV0dXJuIGlkZW50aXRpZXM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFueSBtYXRjaCB0byB0aGUgcHJvcGVydHkgYW5kIGV2YWx1dGF0ZXMgaWYgdHJ1dGh5XHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7UHJvcGVydHl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBtYXRjaCBjb25maXJtZWQgYW5kIHRydXRoeSB3aWxsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gZm91bmRGYWxzeShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlkZW50aXR5ID0gc2luZ2xlUHJvcGVydHkoaWRlbnRpdHkpO1xuICBpZiAoaXNGYWxzeShpZGVudGl0eSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gX2ZvdW5kRmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoLCBjdXJyZW50RGVwdGggPSAwKSB7XG4gICAgaWYgKGNvbnRhaW5zS2V5cyhjb2xsZWN0aW9uLCBbaWRlbnRpdHldKSkgcmV0dXJuIGlzRmFsc3koY29sbGVjdGlvbltpZGVudGl0eV0pO1xuICAgIGlmIChtYXhEZXB0aCAhPT0gbnVsbCkgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBzdWJjb2xsZWN0aW9uID0gY29sbGVjdGlvbltrZXldLFxuICAgICAgICAgICAgcmVzID0gX2ZvdW5kRmFsc3koc3ViY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcblxuICAgICAgaWYgKHJlcykgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfZm91bmRGYWxzeShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIGZvciBlYWNoIGlkZW50aXR5IG9uIGNvbGxlY3Rpb24sIHRvIHNob3J0ZW4gdGhlIGlkZW50aXRpZXMgdG8gdGhvc2UgdGhhdCBtZWV0cyB0aGUgbWF0Y2ggY3JpdGVyaWFcclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXRpZXNcclxuICogQHBhcmFtIHtBbnl9IHByb3BlcnR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBbnl9IFJldHVybnMgYSBjb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlICdpZGVudGl0aWVzJyBwYXJhbWV0ZXIgcHJvdmlkZWQgd2l0aCBvbmx5IHRoZSBpZGVudGl0aWVzIHRoYXQgbWF0Y2hlZC5cclxuICovXG5cblxuZnVuY3Rpb24gb25seVRydXRoeShjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBwcm9wZXJ0eSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlmIChnZXRUeXBlKGlkZW50aXRpZXMpID09PSAnYXJyYXknKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGlkZW50aXRpZXMuZm9yRWFjaChpZGVudGl0eSA9PiB7XG4gICAgICBjb25zdCBzdWJDb2xsZWN0aW9uID0gZGVlcEZpbHRlcihjb2xsZWN0aW9uLCBpZGVudGl0eSk7XG4gICAgICBpZiAoaXNUcnV0aHkoc3ViQ29sbGVjdGlvbikpIGlmIChmb3VuZFRydXRoeShzdWJDb2xsZWN0aW9uLCBwcm9wZXJ0eSwgbWF4RGVwdGgpKSByZXN1bHQucHVzaChpZGVudGl0eSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChnZXRUeXBlKGlkZW50aXRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBpZGVudGl0eSA9IGlkZW50aXRpZXNba2V5XSxcbiAgICAgICAgICAgIHN1YkNvbGxlY3Rpb24gPSBkZWVwRmlsdGVyKGNvbGxlY3Rpb24sIGlkZW50aXR5KTtcbiAgICAgIGlmIChpc1RydXRoeShzdWJDb2xsZWN0aW9uKSkgaWYgKGZvdW5kVHJ1dGh5KHN1YkNvbGxlY3Rpb24sIHByb3BlcnR5LCBtYXhEZXB0aCkpIHJlc3VsdFtrZXldID0gaWRlbnRpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChmb3VuZFRydXRoeShjb2xsZWN0aW9uLCBwcm9wZXJ0eSwgbWF4RGVwdGgpKSByZXR1cm4gaWRlbnRpdGllcztcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYW55IG1hdGNoIHRvIHRoZSBwcm9wZXJ0eSBhbmQgZXZhbHV0YXRlcyBpZiB0cnV0aHlcclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtQcm9wZXJ0eX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIG1hdGNoIGNvbmZpcm1lZCBhbmQgdHJ1dGh5IHdpbGwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBmb3VuZFRydXRoeShjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIGlkZW50aXR5ID0gc2luZ2xlUHJvcGVydHkoaWRlbnRpdHkpO1xuICBpZiAoaXNGYWxzeShpZGVudGl0eSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gX2ZvdW5kVHJ1dGh5KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCwgY3VycmVudERlcHRoID0gMCkge1xuICAgIGlmIChjb250YWluc0tleXMoY29sbGVjdGlvbiwgW2lkZW50aXR5XSkpIHJldHVybiBpc1RydXRoeShjb2xsZWN0aW9uW2lkZW50aXR5XSk7XG4gICAgaWYgKG1heERlcHRoICE9PSBudWxsKSBpZiAoY3VycmVudERlcHRoID49IG1heERlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHN1YmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uW2tleV0sXG4gICAgICAgICAgICByZXMgPSBfZm91bmRUcnV0aHkoc3ViY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcblxuICAgICAgaWYgKHJlcykgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfZm91bmRUcnV0aHkoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoLCAwKTtcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZXMgaWYgaWRlbnRpdHkgaXMgZXF1YWwgdG8gYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9yIGNvbnRhaW5zIGEgc2luZ2xlIHByb3BlcnR5IGtleS5cclxuICogQHBhcmFtIHtQcm9wZXJ0eX0gaWRlbnRpdHlcclxuICogQHJldHVybiB7U3RyaW5nIHx8IGJvb2xlYW59IElmIGNyaXRlcmlhIG1hdGNoZWQgd2lsbCByZXR1cm4gcHJvcGVydHkgbmFtZSBhcyBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzaW5nbGVQcm9wZXJ0eShpZGVudGl0eSkge1xuICBjb25zdCBwcm9wQ291bnQgPSBsZW5ndGgoaWRlbnRpdHkpO1xuICBpZiAocHJvcENvdW50ID4gMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAocHJvcENvdW50ID09PSAxKSByZXR1cm4gT2JqZWN0LmtleXMoaWRlbnRpdHkpWzBdO1xuICBpZiAocHJvcENvdW50ID09PSAwKSBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJ10uaW5kZXhPZihnZXRUeXBlKGlkZW50aXR5KSkgPiAtMSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gZmFsc2U7XG59XG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBpZGVudGl0eSBpcyBub24tZmFsc3lcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBjcml0ZXJpYSBtYXRjaGVkLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVHJ1dGh5KGlkZW50aXR5KSB7XG4gIHJldHVybiAhaXNGYWxzeShpZGVudGl0eSk7XG59XG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBpZGVudGl0eSBpcyBmYWxzeVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGNyaXRlcmlhIG1hdGNoZWQsIG90aGVyd2lzZSBmYWxzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNGYWxzeShpZGVudGl0eSkge1xuICBpZiAoZmFsc2VyKGlkZW50aXR5KSA9PT0gZmFsc2UpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG4vKipcclxuICogQ29udmVydHMgZmFsc2UtbGlrZSB2YWx1ZXMgaW50byBhY3R1YWwgYm9vbGVhbiB2YWx1ZSBvZiBmYWxzZVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHJldHVybiB7QW55IHx8IGJvb2xlYW59IFJldHVybnMgZmFsc2UgaXMgdmFsdWUgaXMgZmFsc3ksIG90aGVyd2lzZSByZXR1cm5zIG9yaWdpbmFsIHZhbHVlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmYWxzZXIoaWRlbnRpdHkpIHtcbiAgaWYgKGlzSXRlcmFibGUoaWRlbnRpdHkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmIChbJ251bGwnLCAndW5kZWZpbmVkJ10uaW5kZXhPZihnZXRUeXBlKGlkZW50aXR5KSkgPiAtMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWycnLCAwLCBmYWxzZV0uaW5kZXhPZihpZGVudGl0eSkgPiAtMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaWRlbnRpdHk7XG59XG4vKipcclxuICogQ2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgdG9wLW1vc3QgZGVwdGggb2YgdGhlIGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBHcmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMC5cclxuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKGlkZW50aXR5KSB7XG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YoZ2V0VHlwZShpZGVudGl0eSkpID09PSAtMSkgcmV0dXJuIDA7XG4gIHJldHVybiBPYmplY3Qua2V5cyhpZGVudGl0eSkubGVuZ3RoO1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGRlZXAgc2VhcmNoIGZvciBlYWNoIGlkZW50aXR5IG9uIGNvbGxlY3Rpb24sIHRvIHNob3J0ZW4gdGhlIGlkZW50aXRpZXMgdG8gdGhvc2UgdGhhdCBkb2VzIG1lZXRzIHRoZSBtYXRjaCBjcml0ZXJpYVxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdGllc1xyXG4gKiBAcGFyYW0ge09wdGlvbmFsIE51bWJlcn0gbWF4RGVwdGhcclxuICogQHJldHVybiB7QW55fSBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSAnaWRlbnRpdGllcycgcGFyYW1ldGVyIHByb3ZpZGVkIHdpdGggb25seSB0aGUgaWRlbnRpdGllcyB0aGF0IHdlcmUgbm90IG1hdGNoZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlNaXNzaW5nKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ2FycmF5Jykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZGVudGl0aWVzLmZvckVhY2goaWRlbnRpdHkgPT4ge1xuICAgICAgaWYgKCFleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKSkgcmVzdWx0LnB1c2goaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoaWRlbnRpdGllcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbGV0IGlkZW50aXR5ID0gaWRlbnRpdGllc1trZXldO1xuICAgICAgaWYgKCFleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKSkgcmVzdWx0W2tleV0gPSBpZGVudGl0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgbWF4RGVwdGgpKSByZXR1cm4gaWRlbnRpdGllcztcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBmb3IgZWFjaCBpZGVudGl0eSBvbiBjb2xsZWN0aW9uLCB0byBzaG9ydGVuIHRoZSBpZGVudGl0aWVzIHRvIHRob3NlIHRoYXQgbWVldHMgdGhlIG1hdGNoIGNyaXRlcmlhXHJcbiAqIEBwYXJhbSB7QW55fSBjb2xsZWN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0aWVzXHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBbnl9IFJldHVybnMgYSBjb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlICdpZGVudGl0aWVzJyBwYXJhbWV0ZXIgcHJvdmlkZWQgd2l0aCBvbmx5IHRoZSBpZGVudGl0aWVzIHRoYXQgbWF0Y2hlZC5cclxuICovXG5cblxuZnVuY3Rpb24gb25seUV4aXN0aW5nKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoID0gbnVsbCkge1xuICBpZiAoZ2V0VHlwZShpZGVudGl0aWVzKSA9PT0gJ2FycmF5Jykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZGVudGl0aWVzLmZvckVhY2goaWRlbnRpdHkgPT4ge1xuICAgICAgaWYgKGV4aXN0cyhjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpKSByZXN1bHQucHVzaChpZGVudGl0eSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChnZXRUeXBlKGlkZW50aXRpZXMpID09PSAnb2JqZWN0Jykge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpZGVudGl0aWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgaWRlbnRpdHkgPSBpZGVudGl0aWVzW2tleV07XG4gICAgICBpZiAoZXhpc3RzKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkpIHJlc3VsdFtrZXldID0gaWRlbnRpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgbWF4RGVwdGgpKSByZXR1cm4gaWRlbnRpdGllcztcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYW55IG1hdGNoIHRvIHRoZSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGEgbWF0Y2ggaXMgY29uZmlybWVkIHdpbGwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCwgY3VycmVudERlcHRoID0gMCkge1xuICBpZiAoaWRlbnRpY2FsKGNvbGxlY3Rpb24sIGlkZW50aXR5KSkgcmV0dXJuIHRydWU7XG4gIGlmIChpc0l0ZXJhYmxlKGlkZW50aXR5KSkgaWYgKHNhbWVUeXBlKGNvbGxlY3Rpb24sIGlkZW50aXR5KSkgaWYgKGNvbnRhaW5zS2V5cyhjb2xsZWN0aW9uLCBPYmplY3Qua2V5cyhpZGVudGl0eSkpKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IHRyaW0oY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKTtcbiAgICBpZiAoaWRlbnRpY2FsKHRyaW1tZWQsIGlkZW50aXR5KSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG1heERlcHRoID09PSBudWxsID8gdHJ1ZSA6IGN1cnJlbnREZXB0aCA8IG1heERlcHRoKSBpZiAoaXNJdGVyYWJsZShjb2xsZWN0aW9uKSkgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKSwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICBzdWJjb2xsZWN0aW9uID0gY29sbGVjdGlvbltrZXldLFxuICAgICAgICAgIHJlcyA9IGV4aXN0cyhzdWJjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgIGlmIChyZXMpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYWxsIG1hdGNoZXMgdG8gdGhlIGlkZW50aXR5LCB3aWxsIHJldHVybiBhIGxpc3Qgb2YgaWRlbnRpdGllcyBjb250YWluaW5nIHRoZSBtYXRjaC4gSWYgbm8gbWF0Y2hlcyBmb3VuZCwgaXQgcmV0dXJucyBgdW5kZWZpbmVkYC5cclxuICogQHBhcmFtIHtBbnl9IGNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEBwYXJhbSB7T3B0aW9uYWwgTnVtYmVyfSBtYXhEZXB0aFxyXG4gKiBAcmV0dXJuIHtBcnJheSB8fCB1bmRlZmluZWR9IGlkZW50aXRpZXNcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcEZpbHRlcihjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIHZhciBwYXRocyA9IGxvY2F0ZUFsbChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGgpO1xuICBpZiAocGF0aHMgPT09IGZhbHNlKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCByZXN1bHRzID0gcGF0aHMubWFwKHBhdGggPT4ge1xuICAgIGlmIChwYXRoID09PSAnJykgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBpZiAoWydhcnJheScsICdvYmplY3QnXS5pbmRleE9mKGdldFR5cGUoaWRlbnRpdHkpKSA9PT0gLTEpIHBhdGguc3BsaWNlKC0xLCAxKTtcbiAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiByZXN1bHRbcGF0aF07XG4gICAgcGF0aC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcclxuICogUGVyZm9ybXMgZGVlcCBzZWFyY2ggb24gY29sbGVjdGlvbiB0byBmaW5kIGFsbCBtYXRjaGVzIHRvIHRoZSBpZGVudGl0eSwgcmV0dXJucyBhIHN0cmluZyBhcnJheSBjb250YWluaW5nIHRoZSBsb2NhdGlvbiBvZiBhbGwgbWF0Y2hlcy4gSWYgbm8gbWF0Y2hlcyBmb3VuZCwgaXQgcmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge0FycmF5IHx8IGZhbHNlfSBQYXRoc1xyXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhdGVBbGwoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICB2YXIgUiA9IFtdO1xuXG4gIGZ1bmN0aW9uIF9sb2NhdGVBbGwoY29sbGVjdGlvbiwgaWRlbnRpdHksIHBhdGggPSAnJywgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCkge1xuICAgIGlmIChpc0l0ZXJhYmxlKGlkZW50aXR5KSkgaWYgKHNhbWVUeXBlKGNvbGxlY3Rpb24sIGlkZW50aXR5KSkgaWYgKGNvbnRhaW5zS2V5cyhjb2xsZWN0aW9uLCBPYmplY3Qua2V5cyhpZGVudGl0eSkpKSB7XG4gICAgICBjb25zdCB0cmltbWVkID0gdHJpbShjb2xsZWN0aW9uLCBPYmplY3Qua2V5cyhpZGVudGl0eSkpO1xuICAgICAgaWYgKGlkZW50aWNhbCh0cmltbWVkLCBpZGVudGl0eSkpIFJbUi5sZW5ndGhdID0gcGF0aDtcbiAgICB9XG4gICAgaWYgKGlkZW50aWNhbChjb2xsZWN0aW9uLCBpZGVudGl0eSkpIFJbUi5sZW5ndGhdID0gcGF0aDtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKG1heERlcHRoICE9PSBudWxsKSBpZiAoY3VycmVudERlcHRoID49IG1heERlcHRoKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV0sXG4gICAgICAgICAgICBzdWJjb2xsZWN0aW9uID0gY29sbGVjdGlvbltrZXldO1xuXG4gICAgICBfbG9jYXRlQWxsKHN1YmNvbGxlY3Rpb24sIGlkZW50aXR5LCAocGF0aCA9PT0gJycgPyBwYXRoIDogcGF0aCArICcuJykgKyBrZXksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICB9XG4gIH1cblxuICBfbG9jYXRlQWxsKGNvbGxlY3Rpb24sIGlkZW50aXR5LCAnJywgbWF4RGVwdGgsIDApO1xuXG4gIHJldHVybiBSLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogUjtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYSBtYXRjaCB0byB0aGUgaWRlbnRpdHksIHdpbGwgcmV0dXJuIHRoZSBpZGVudGl0eSBjb250YWluaW5nIG9mIHRoZSBmaXJzdCBpbnN0YW5jZSBtYXRjaGVkLiBJZiBubyBtYXRjaGVzIGZvdW5kLCBpdCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBOdW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge2lkZW50aXR5IHx8IHVuZGVmaW5lZH0gaWRlbnRpdHlcclxuICovXG5cblxuZnVuY3Rpb24gZGVlcEdldChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbWF4RGVwdGggPSBudWxsKSB7XG4gIHZhciBwYXRoID0gbG9jYXRlKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIGlmIChwYXRoID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHBhdGggPT09ICcnKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKFsnYXJyYXknLCAnb2JqZWN0J10uaW5kZXhPZihnZXRUeXBlKGlkZW50aXR5KSkgPT09IC0xKSBwYXRoLnNwbGljZSgtMSwgMSk7XG4gIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiByZXN1bHRbcGF0aF07XG4gIHBhdGguZm9yRWFjaChrZXkgPT4ge1xuICAgIHJlc3VsdCA9IHJlc3VsdFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBkZWVwIHNlYXJjaCBvbiBjb2xsZWN0aW9uIHRvIGZpbmQgYSBtYXRjaCB0byB0aGUgaWRlbnRpdHksIHdpbGwgcmV0dXJuIHRoZSBwYXRoIG9mIHRoZSBmaXJzdCBpbnN0YW5jZSBtYXRjaGVkIGFzIHN0cmluZy4gSWYgbm8gbWF0Y2hlcyBmb3VuZCwgcmV0dXJucyBgZmFsc2VgLlxyXG4gKiBAcGFyYW0ge0FueX0gY29sbGVjdGlvblxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtPcHRpb25hbCBudW1iZXJ9IG1heERlcHRoXHJcbiAqIEByZXR1cm4ge3N0cmluZyB8fCBmYWxzZX0gcGF0aFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhdGUoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoID0gbnVsbCkge1xuICBmdW5jdGlvbiBfbG9jYXRlKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBwYXRoID0gJycsIG1heERlcHRoLCBjdXJyZW50RGVwdGgpIHtcbiAgICBpZiAoaXNJdGVyYWJsZShpZGVudGl0eSkpIGlmIChzYW1lVHlwZShjb2xsZWN0aW9uLCBpZGVudGl0eSkpIGlmIChjb250YWluc0tleXMoY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW0oY29sbGVjdGlvbiwgT2JqZWN0LmtleXMoaWRlbnRpdHkpKTtcbiAgICAgIGlmIChpZGVudGljYWwodHJpbW1lZCwgaWRlbnRpdHkpKSByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgaWYgKGlkZW50aWNhbChjb2xsZWN0aW9uLCBpZGVudGl0eSkpIHJldHVybiBwYXRoO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAobWF4RGVwdGggIT09IG51bGwpIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIGZvciAodmFyIGkgPSAwLCBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbiksIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgICAgIHN1YmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uW2tleV0sXG4gICAgICAgICAgICByZXMgPSBfbG9jYXRlKHN1YmNvbGxlY3Rpb24sIGlkZW50aXR5LCBrZXksIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICBwYXRoID0gcGF0aCA9PT0gJycgPyBwYXRoIDogcGF0aCArICcuJztcbiAgICAgICAgcmVzdWx0ID0gcGF0aCArIHJlcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gX2xvY2F0ZShjb2xsZWN0aW9uLCBpZGVudGl0eSwgJycsIG1heERlcHRoLCAwKTtcbn1cbi8qKlxyXG4gKiBUcmltcyBhbiBpZGVudGl0eSB0byBvbmx5IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlcclxuICogQHBhcmFtIHtBbnl9IGtleUxpc3RcclxuICogQHJldHVybiB7T2JqZWN0IG9yIEFycmF5fSBSZXR1cm5zICwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyaW0oaWRlbnRpdHksIGtleUxpc3QpIHtcbiAgY29uc3QgaWRlbnRpdHlUeXBlID0gZ2V0VHlwZShpZGVudGl0eSk7XG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YoaWRlbnRpdHlUeXBlKSA9PT0gLTEpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNvbnN0IGtleUNvdW50ID0ga2V5TGlzdC5sZW5ndGg7XG4gIGlmIChrZXlDb3VudCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIG5ld0lkZW50aXR5O1xuXG4gIHN3aXRjaCAoaWRlbnRpdHlUeXBlKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIG5ld0lkZW50aXR5ID0ge307XG4gICAgICBrZXlMaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSBpbiBpZGVudGl0eSkgbmV3SWRlbnRpdHlba2V5XSA9IGlkZW50aXR5W2tleV07XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgbmV3SWRlbnRpdHkgPSBbXTtcbiAgICAgIGtleUxpc3QuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5IGluIGlkZW50aXR5KSBuZXdJZGVudGl0eS5wdXNoKGlkZW50aXR5W2tleV0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBuZXdJZGVudGl0eTtcbn1cbi8qKlxyXG4gKiBDaGVjayBpZiBpZGVudGl0eSBjb250YWlucyBhbGwgb2YgdGhlIHNwZWNpZmllZCBrZXlzXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlMaXN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgfHwgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gY29udGFpbnNLZXlzKGlkZW50aXR5LCBrZXlMaXN0KSB7XG4gIGNvbnN0IGtleUNvdW50ID0ga2V5TGlzdC5sZW5ndGg7XG4gIGlmIChrZXlDb3VudCA9PT0gMCB8fCAhaXNJdGVyYWJsZShpZGVudGl0eSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaWRlbnRpdHlrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSAnJyArIGtleUxpc3RbaV07XG5cbiAgICBpZiAoaWRlbnRpdHlrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBDaGVjayBpZiBpZGVudGl0eSBoYXMgb25lIG9yIG1vcmUga2V5cyB0byBpdGVyYXRlXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eVxyXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIHx8IGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUoaWRlbnRpdHkpIHtcbiAgaWYgKFsnYXJyYXknLCAnb2JqZWN0J10uaW5kZXhPZihnZXRUeXBlKGlkZW50aXR5KSkgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGl0eSkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBpZGVudGl0aWVzLCB3aWxsIHJldHVybiBlaXRoZXIgdHJ1ZSBpZiBpZGVudGljYWwsIG90aGVyd2lzZSBmYWxzZS5cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5QVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlCXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgfHwgZmFsc2VcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpY2FsKGlkZW50aXR5QSwgaWRlbnRpdHlCKSB7XG4gIGNvbnN0IHN0cnVjdHVyZU1hdGNoID0gc2FtZVN0cnVjdHVyZShpZGVudGl0eUEsIGlkZW50aXR5Qik7XG4gIGlmIChzdHJ1Y3R1cmVNYXRjaCA9PT0gZmFsc2UpIHJldHVybiBzdHJ1Y3R1cmVNYXRjaDtcbiAgaWYgKFsnYXJyYXknLCAnb2JqZWN0J10uaW5kZXhPZihzdHJ1Y3R1cmVNYXRjaCkgPT09IC0xKSByZXR1cm4gaWRlbnRpdHlBID09PSBpZGVudGl0eUI7XG4gIGNvbnN0IEtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eUEpLFxuICAgICAgICBLZXlDb3VudCA9IEtleXMubGVuZ3RoO1xuICB2YXIgY2hpbGRNYXRjaCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBLZXlDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgS2V5ID0gS2V5c1tpXSxcbiAgICAgICAgICBpZGVudGljYWxNYXRjaCA9IGlkZW50aWNhbChpZGVudGl0eUFbS2V5XSwgaWRlbnRpdHlCW0tleV0pO1xuXG4gICAgaWYgKGlkZW50aWNhbE1hdGNoID09PSBmYWxzZSkge1xuICAgICAgY2hpbGRNYXRjaCA9IGlkZW50aWNhbE1hdGNoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkTWF0Y2g7XG59XG4vKipcclxuICogQ29tcGFyZXMgZGF0YSBzdHJ1Y3R1cmUgb2YgdHdvIGlkZW50aXRpZXMsIHdpbGwgcmV0dXJuIGVpdGhlciB0aGUgZGF0YVR5cGUgb3IgdHJ1ZS9mYWxzZS5cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5QVxyXG4gKiBAcGFyYW0ge0FueX0gaWRlbnRpdHlCXHJcbiAqIEByZXR1cm4ge1N0cmluZyB8fCBGYWxzZX0gRGF0YVR5cGUgYXMgc3RyaW5nIGZvciBwb3NpdGl2ZSBtYXRjaCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhbWVTdHJ1Y3R1cmUoaWRlbnRpdHlBLCBpZGVudGl0eUIpIHtcbiAgY29uc3QgdHlwZU1hdGNoID0gc2FtZVR5cGUoaWRlbnRpdHlBLCBpZGVudGl0eUIpO1xuICBpZiAodHlwZU1hdGNoID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChbJ2FycmF5JywgJ29iamVjdCddLmluZGV4T2YodHlwZU1hdGNoKSA+IC0xKSB7XG4gICAgY29uc3QgQUtleXMgPSBPYmplY3Qua2V5cyhpZGVudGl0eUEpLFxuICAgICAgICAgIEJLZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHlCKSxcbiAgICAgICAgICBBS2V5Q291bnQgPSBBS2V5cy5sZW5ndGgsXG4gICAgICAgICAgQktleUNvdW50ID0gQktleXMubGVuZ3RoO1xuICAgIGlmICghKEFLZXlDb3VudCA9PT0gQktleUNvdW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChBS2V5Q291bnQgPT09IDApIHJldHVybiB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBBS2V5Q291bnQ7IGkrKykge1xuICAgICAgaWYgKEFLZXlzW2ldICE9PSBCS2V5c1tpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlTWF0Y2g7XG59XG4vKipcclxuICogQ29tcGFyZXMgZGF0YSB0eXBlIG9mIHR3byBpZGVudGl0aWVzLCB3aWxsIGRhdGFUeXBlIGlmIHRydWUuXHJcbiAqIEBwYXJhbSB7QW55fSBpZGVudGl0eUFcclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5QlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIHx8IGZhbHNlXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhbWVUeXBlKGlkZW50aXR5QSwgaWRlbnRpdHlCKSB7XG4gIGNvbnN0IHR5cGVBID0gZ2V0VHlwZShpZGVudGl0eUEpO1xuICByZXR1cm4gdHlwZUEgPT09IGdldFR5cGUoaWRlbnRpdHlCKSA/IHR5cGVBIDogZmFsc2U7XG59XG4vKipcclxuICogR2V0cyBkYXRhIHR5cGU7IG1ha2VzIGRpc3RpbnRpb24gYmV0d2VlbiBvYmplY3QsIGFycmF5LCBhbmQgbnVsbC5cclxuICogQHBhcmFtIHtBbnl9IGlkZW50aXR5XHJcbiAqIEByZXR1cm4ge1N0cmluZ30gZGF0YVR5cGVcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHlwZShpZGVudGl0eSkge1xuICBpZiAoaWRlbnRpdHkgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGNvbnN0IGl0ID0gdHlwZW9mIGlkZW50aXR5O1xuICBpZiAoaXQgPT09ICdvYmplY3QnKSBpZiAoQXJyYXkuaXNBcnJheShpZGVudGl0eSkpIHJldHVybiAnYXJyYXknO1xuICByZXR1cm4gaXQ7XG59XG5cbnZhciBtaXRzdWtldGEgPSB7XG4gIGdldFR5cGU6IGZ1bmN0aW9uIChpZGVudGl0eSkge1xuICAgIHJldHVybiBnZXRUeXBlKGlkZW50aXR5KTtcbiAgfSxcbiAgc2FtZVR5cGU6IGZ1bmN0aW9uIChpZGVudGl0eUEsIGlkZW50aXR5Qikge1xuICAgIHJldHVybiBzYW1lVHlwZShpZGVudGl0eUEsIGlkZW50aXR5Qik7XG4gIH0sXG4gIHNhbWVTdHJ1Y3R1cmU6IGZ1bmN0aW9uIChpZGVudGl0eUEsIGlkZW50aXR5Qikge1xuICAgIHJldHVybiBzYW1lU3RydWN0dXJlKGlkZW50aXR5QSwgaWRlbnRpdHlCKTtcbiAgfSxcbiAgaWRlbnRpY2FsOiBmdW5jdGlvbiAoaWRlbnRpdHlBLCBpZGVudGl0eUIpIHtcbiAgICByZXR1cm4gaWRlbnRpY2FsKGlkZW50aXR5QSwgaWRlbnRpdHlCKTtcbiAgfSxcbiAgaXNJdGVyYWJsZTogZnVuY3Rpb24gKGlkZW50aXR5KSB7XG4gICAgcmV0dXJuIGlzSXRlcmFibGUoaWRlbnRpdHkpO1xuICB9LFxuICBjb250YWluc0tleXM6IGZ1bmN0aW9uIChpZGVudGl0eSwga2V5TGlzdCkge1xuICAgIHJldHVybiBjb250YWluc0tleXMoaWRlbnRpdHksIGtleUxpc3QpO1xuICB9LFxuICB0cmltOiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleUxpc3QpIHtcbiAgICByZXR1cm4gdHJpbShpZGVudGl0eSwga2V5TGlzdCk7XG4gIH0sXG4gIGxvY2F0ZTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBsb2NhdGUoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcEdldDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBkZWVwR2V0KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIGxvY2F0ZUFsbDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBsb2NhdGVBbGwoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcEZpbHRlcjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBkZWVwRmlsdGVyKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIGV4aXN0czogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBleGlzdHMoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgfSxcbiAgb25seUV4aXN0aW5nOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gb25seUV4aXN0aW5nKGNvbGxlY3Rpb24sIGlkZW50aXRpZXMsIG1heERlcHRoKTtcbiAgfSxcbiAgb25seU1pc3Npbmc6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBvbmx5TWlzc2luZyhjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGxlbmd0aDogZnVuY3Rpb24gKGlkZW50aXR5KSB7XG4gICAgcmV0dXJuIGxlbmd0aChpZGVudGl0eSk7XG4gIH0sXG4gIGlzRmFsc3k6IGZ1bmN0aW9uIChpZGVudGl0eSkge1xuICAgIHJldHVybiBpc0ZhbHN5KGlkZW50aXR5KTtcbiAgfSxcbiAgaXNUcnV0aHk6IGZ1bmN0aW9uIChpZGVudGl0eSkge1xuICAgIHJldHVybiBpc1RydXRoeShpZGVudGl0eSk7XG4gIH0sXG4gIGZvdW5kVHJ1dGh5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIGZvdW5kVHJ1dGh5KGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIG9ubHlUcnV0aHk6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBwcm9wZXJ0eSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gb25seVRydXRoeShjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBwcm9wZXJ0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBmb3VuZEZhbHN5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIGZvdW5kRmFsc3koY29sbGVjdGlvbiwgaWRlbnRpdHksIG1heERlcHRoKTtcbiAgfSxcbiAgb25seUZhbHN5OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWRlbnRpdGllcywgcHJvcGVydHksIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIG9ubHlGYWxzeShjb2xsZWN0aW9uLCBpZGVudGl0aWVzLCBwcm9wZXJ0eSwgbWF4RGVwdGgpO1xuICB9LFxuICBjb3VudE1hdGNoZXM6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpZGVudGl0eSwgbnRoRGVwdGgsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIGNvdW50TWF0Y2hlcyhjb2xsZWN0aW9uLCBpZGVudGl0eSwgbnRoRGVwdGgsIG1heERlcHRoKTtcbiAgfSxcbiAgbWF0Y2hEZXB0aDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBtYXRjaERlcHRoKGNvbGxlY3Rpb24sIGlkZW50aXR5LCBtYXhEZXB0aCk7XG4gIH0sXG4gIG1heERlcHRoOiBmdW5jdGlvbiAoaWRlbnRpdHksIG1heExheWVyKSB7XG4gICAgcmV0dXJuIG1heERlcHRoKGlkZW50aXR5LCBtYXhMYXllcik7XG4gIH0sXG4gIGxvY2F0ZV9LZXk6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBsb2NhdGVfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcEdldF9LZXk6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBkZWVwR2V0X0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGxvY2F0ZUFsbF9LZXk6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBsb2NhdGVBbGxfS2V5KGNvbGxlY3Rpb24sIGtleU5hbWUsIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcEZpbHRlcl9LZXk6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCkge1xuICAgIHJldHVybiBkZWVwRmlsdGVyX0tleShjb2xsZWN0aW9uLCBrZXlOYW1lLCBtYXhEZXB0aCk7XG4gIH0sXG4gIGRlZXBDbG9uZTogZnVuY3Rpb24gKGlkZW50aXR5LCBtYXhEZXB0aCwgc3RhcnREZXB0aCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUoaWRlbnRpdHksIG1heERlcHRoLCBzdGFydERlcHRoKTtcbiAgfSxcbiAgcmVuYW1lS2V5OiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIHJlbmFtZUtleShpZGVudGl0eSwga2V5TmFtZSwgbmV3S2V5TmFtZSwgbWF4RGVwdGgpO1xuICB9LFxuICByZW5hbWVLZXlzOiBmdW5jdGlvbiAoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoKSB7XG4gICAgcmV0dXJuIHJlbmFtZUtleXMoaWRlbnRpdHksIGtleU5hbWUsIG5ld0tleU5hbWUsIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcFJlbW92ZV9LZXk6IGZ1bmN0aW9uIChpZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcFJlbW92ZV9LZXkoaWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKTtcbiAgfSxcbiAgZGVlcFJlbW92ZUFsbF9LZXk6IGZ1bmN0aW9uIChpZGVudGl0eSwga2V5TmFtZSwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gZGVlcFJlbW92ZUFsbF9LZXkoaWRlbnRpdHksIGtleU5hbWUsIG1heERlcHRoKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG1pdHN1a2V0YTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/mitsuketa/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/themes.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/es/themes.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst dark_vscode_tribute = {\n  default: '#D4D4D4',\n  background: '#1E1E1E',\n  background_warning: '#1E1E1E',\n  string: '#CE8453',\n  number: '#B5CE9F',\n  colon: '#49B8F7',\n  keys: '#9CDCFE',\n  keys_whiteSpace: '#AF74A5',\n  primitive: '#6392C6'\n};\nconst light_mitsuketa_tribute = {\n  default: '#D4D4D4',\n  background: '#FCFDFD',\n  background_warning: '#FEECEB',\n  string: '#FA7921',\n  number: '#70CE35',\n  colon: '#49B8F7',\n  keys: '#59A5D8',\n  keys_whiteSpace: '#835FB6',\n  primitive: '#386FA4'\n};\nconst themes = {\n  dark_vscode_tribute: dark_vscode_tribute,\n  light_mitsuketa_tribute: light_mitsuketa_tribute\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (themes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2VzL3RoZW1lcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWpzb24tZWRpdG9yLWFqcm0vZXMvdGhlbWVzLmpzPzg4MzIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGFya192c2NvZGVfdHJpYnV0ZSA9IHtcbiAgZGVmYXVsdDogJyNENEQ0RDQnLFxuICBiYWNrZ3JvdW5kOiAnIzFFMUUxRScsXG4gIGJhY2tncm91bmRfd2FybmluZzogJyMxRTFFMUUnLFxuICBzdHJpbmc6ICcjQ0U4NDUzJyxcbiAgbnVtYmVyOiAnI0I1Q0U5RicsXG4gIGNvbG9uOiAnIzQ5QjhGNycsXG4gIGtleXM6ICcjOUNEQ0ZFJyxcbiAga2V5c193aGl0ZVNwYWNlOiAnI0FGNzRBNScsXG4gIHByaW1pdGl2ZTogJyM2MzkyQzYnXG59O1xuY29uc3QgbGlnaHRfbWl0c3VrZXRhX3RyaWJ1dGUgPSB7XG4gIGRlZmF1bHQ6ICcjRDRENEQ0JyxcbiAgYmFja2dyb3VuZDogJyNGQ0ZERkQnLFxuICBiYWNrZ3JvdW5kX3dhcm5pbmc6ICcjRkVFQ0VCJyxcbiAgc3RyaW5nOiAnI0ZBNzkyMScsXG4gIG51bWJlcjogJyM3MENFMzUnLFxuICBjb2xvbjogJyM0OUI4RjcnLFxuICBrZXlzOiAnIzU5QTVEOCcsXG4gIGtleXNfd2hpdGVTcGFjZTogJyM4MzVGQjYnLFxuICBwcmltaXRpdmU6ICcjMzg2RkE0J1xufTtcbmNvbnN0IHRoZW1lcyA9IHtcbiAgZGFya192c2NvZGVfdHJpYnV0ZTogZGFya192c2NvZGVfdHJpYnV0ZSxcbiAgbGlnaHRfbWl0c3VrZXRhX3RyaWJ1dGU6IGxpZ2h0X21pdHN1a2V0YV90cmlidXRlXG59O1xuZXhwb3J0IGRlZmF1bHQgdGhlbWVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/es/themes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-json-editor-ajrm/locale/en.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-json-editor-ajrm/locale/en.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = {\n  format: \"{reason} at line {line}\",\n  symbols: {\n    colon: \"colon\",\n    // :\n    comma: \"comma\",\n    // ,  ،  、\n    semicolon: \"semicolon\",\n    // ;\n    slash: \"slash\",\n    // /  relevant for comment syntax support\n    backslash: \"backslash\",\n    // \\  relevant for escaping character\n    brackets: {\n      round: \"round brackets\",\n      // ( )\n      square: \"square brackets\",\n      // [ ]\n      curly: \"curly brackets\",\n      // { }\n      angle: \"angle brackets\" // < >\n\n    },\n    period: \"period\",\n    // . Also known as full point, full stop, or dot\n    quotes: {\n      single: \"single quote\",\n      // '\n      double: \"double quote\",\n      // \"\n      grave: \"grave accent\" // ` used on Javascript ES6 Syntax for String Templates\n\n    },\n    space: \"space\",\n    //       \n    ampersand: \"ampersand\",\n    //\t&\n    asterisk: \"asterisk\",\n    //\t*  relevant for some comment sytanx\n    at: \"at sign\",\n    //\t@  multiple uses in other coding languages including certain data types\n    equals: \"equals sign\",\n    //\t=\n    hash: \"hash\",\n    //\t#\n    percent: \"percent\",\n    //\t%\n    plus: \"plus\",\n    //\t+\n    minus: \"minus\",\n    //\t−\n    dash: \"dash\",\n    //\t−\n    hyphen: \"hyphen\",\n    //\t−\n    tilde: \"tilde\",\n    //\t~\n    underscore: \"underscore\",\n    //\t_\n    bar: \"vertical bar\" //\t|\n\n  },\n  types: {\n    key: \"key\",\n    value: \"value\",\n    number: \"number\",\n    string: \"string\",\n    primitive: \"primitive\",\n    boolean: \"boolean\",\n    character: \"character\",\n    integer: \"integer\",\n    array: \"array\",\n    float: \"float\" //... Reference: https://en.wikipedia.org/wiki/List_of_data_structures\n\n  },\n  invalidToken: {\n    tokenSequence: {\n      prohibited: \"'{firstToken}' token cannot be followed by '{secondToken}' token(s)\",\n      permitted: \"'{firstToken}' token can only be followed by '{secondToken}' token(s)\"\n    },\n    termSequence: {\n      prohibited: \"A {firstTerm} cannot be followed by a {secondTerm}\",\n      permitted: \"A {firstTerm} can only be followed by a {secondTerm}\"\n    },\n    double: \"'{token}' token cannot be followed by another '{token}' token\",\n    useInstead: \"'{badToken}' token is not accepted. Use '{goodToken}' instead\",\n    unexpected: \"Unexpected '{token}' token found\"\n  },\n  brace: {\n    curly: {\n      missingOpen: \"Missing '{' open curly brace\",\n      missingClose: \"Open '{' curly brace is missing closing '}' curly brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '{}' curly braces\"\n    },\n    square: {\n      missingOpen: \"Missing '[' open square brace\",\n      missingClose: \"Open '[' square brace is missing closing ']' square brace\",\n      cannotWrap: \"'{token}' token cannot be wrapped in '[]' square braces\"\n    }\n  },\n  string: {\n    missingOpen: \"Missing/invalid opening string '{quote}' token\",\n    missingClose: \"Missing/invalid closing string '{quote}' token\",\n    mustBeWrappedByQuotes: \"Strings must be wrapped by quotes\",\n    nonAlphanumeric: \"Non-alphanumeric token '{token}' is not allowed outside string notation\",\n    unexpectedKey: \"Unexpected key found at string position\"\n  },\n  key: {\n    numberAndLetterMissingQuotes: \"Key beginning with number and containing letters must be wrapped by quotes\",\n    spaceMissingQuotes: \"Key containing space must be wrapped by quotes\",\n    unexpectedString: \"Unexpected string found at key position\"\n  },\n  noTrailingOrLeadingComma: \"Trailing or leading commas in arrays and objects are not permitted\"\n};\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1qc29uLWVkaXRvci1hanJtL2xvY2FsZS9lbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0EsWUFBWSxRQUFRLFNBQVMsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFdBQVcsZ0NBQWdDLFlBQVk7QUFDNUUsb0JBQW9CLFdBQVcsa0NBQWtDLFlBQVk7QUFDN0UsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLFdBQVcseUJBQXlCLFdBQVc7QUFDckUscUJBQXFCLFdBQVcsMkJBQTJCLFdBQVc7QUFDdEUsS0FBSztBQUNMLGVBQWUsTUFBTSx3Q0FBd0MsTUFBTTtBQUNuRSxtQkFBbUIsU0FBUywrQkFBK0IsVUFBVTtBQUNyRSw4QkFBOEIsTUFBTTtBQUNwQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEIsbUNBQW1DO0FBQy9ELHFCQUFxQixNQUFNLGdDQUFnQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtREFBbUQsTUFBTTtBQUN6RCxvREFBb0QsTUFBTTtBQUMxRDtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtanNvbi1lZGl0b3ItYWpybS9sb2NhbGUvZW4uanM/ZmI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IHtcbiAgZm9ybWF0OiBcIntyZWFzb259IGF0IGxpbmUge2xpbmV9XCIsXG4gIHN5bWJvbHM6IHtcbiAgICBjb2xvbjogXCJjb2xvblwiLFxuICAgIC8vIDpcbiAgICBjb21tYTogXCJjb21tYVwiLFxuICAgIC8vICwgINiMICDjgIFcbiAgICBzZW1pY29sb246IFwic2VtaWNvbG9uXCIsXG4gICAgLy8gO1xuICAgIHNsYXNoOiBcInNsYXNoXCIsXG4gICAgLy8gLyAgcmVsZXZhbnQgZm9yIGNvbW1lbnQgc3ludGF4IHN1cHBvcnRcbiAgICBiYWNrc2xhc2g6IFwiYmFja3NsYXNoXCIsXG4gICAgLy8gXFwgIHJlbGV2YW50IGZvciBlc2NhcGluZyBjaGFyYWN0ZXJcbiAgICBicmFja2V0czoge1xuICAgICAgcm91bmQ6IFwicm91bmQgYnJhY2tldHNcIixcbiAgICAgIC8vICggKVxuICAgICAgc3F1YXJlOiBcInNxdWFyZSBicmFja2V0c1wiLFxuICAgICAgLy8gWyBdXG4gICAgICBjdXJseTogXCJjdXJseSBicmFja2V0c1wiLFxuICAgICAgLy8geyB9XG4gICAgICBhbmdsZTogXCJhbmdsZSBicmFja2V0c1wiIC8vIDwgPlxuXG4gICAgfSxcbiAgICBwZXJpb2Q6IFwicGVyaW9kXCIsXG4gICAgLy8gLiBBbHNvIGtub3duIGFzIGZ1bGwgcG9pbnQsIGZ1bGwgc3RvcCwgb3IgZG90XG4gICAgcXVvdGVzOiB7XG4gICAgICBzaW5nbGU6IFwic2luZ2xlIHF1b3RlXCIsXG4gICAgICAvLyAnXG4gICAgICBkb3VibGU6IFwiZG91YmxlIHF1b3RlXCIsXG4gICAgICAvLyBcIlxuICAgICAgZ3JhdmU6IFwiZ3JhdmUgYWNjZW50XCIgLy8gYCB1c2VkIG9uIEphdmFzY3JpcHQgRVM2IFN5bnRheCBmb3IgU3RyaW5nIFRlbXBsYXRlc1xuXG4gICAgfSxcbiAgICBzcGFjZTogXCJzcGFjZVwiLFxuICAgIC8vICAg4oCCICDigINcbiAgICBhbXBlcnNhbmQ6IFwiYW1wZXJzYW5kXCIsXG4gICAgLy9cdCZcbiAgICBhc3RlcmlzazogXCJhc3Rlcmlza1wiLFxuICAgIC8vXHQqICByZWxldmFudCBmb3Igc29tZSBjb21tZW50IHN5dGFueFxuICAgIGF0OiBcImF0IHNpZ25cIixcbiAgICAvL1x0QCAgbXVsdGlwbGUgdXNlcyBpbiBvdGhlciBjb2RpbmcgbGFuZ3VhZ2VzIGluY2x1ZGluZyBjZXJ0YWluIGRhdGEgdHlwZXNcbiAgICBlcXVhbHM6IFwiZXF1YWxzIHNpZ25cIixcbiAgICAvL1x0PVxuICAgIGhhc2g6IFwiaGFzaFwiLFxuICAgIC8vXHQjXG4gICAgcGVyY2VudDogXCJwZXJjZW50XCIsXG4gICAgLy9cdCVcbiAgICBwbHVzOiBcInBsdXNcIixcbiAgICAvL1x0K1xuICAgIG1pbnVzOiBcIm1pbnVzXCIsXG4gICAgLy9cdOKIklxuICAgIGRhc2g6IFwiZGFzaFwiLFxuICAgIC8vXHTiiJJcbiAgICBoeXBoZW46IFwiaHlwaGVuXCIsXG4gICAgLy9cdOKIklxuICAgIHRpbGRlOiBcInRpbGRlXCIsXG4gICAgLy9cdH5cbiAgICB1bmRlcnNjb3JlOiBcInVuZGVyc2NvcmVcIixcbiAgICAvL1x0X1xuICAgIGJhcjogXCJ2ZXJ0aWNhbCBiYXJcIiAvL1x0fFxuXG4gIH0sXG4gIHR5cGVzOiB7XG4gICAga2V5OiBcImtleVwiLFxuICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgbnVtYmVyOiBcIm51bWJlclwiLFxuICAgIHN0cmluZzogXCJzdHJpbmdcIixcbiAgICBwcmltaXRpdmU6IFwicHJpbWl0aXZlXCIsXG4gICAgYm9vbGVhbjogXCJib29sZWFuXCIsXG4gICAgY2hhcmFjdGVyOiBcImNoYXJhY3RlclwiLFxuICAgIGludGVnZXI6IFwiaW50ZWdlclwiLFxuICAgIGFycmF5OiBcImFycmF5XCIsXG4gICAgZmxvYXQ6IFwiZmxvYXRcIiAvLy4uLiBSZWZlcmVuY2U6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfZGF0YV9zdHJ1Y3R1cmVzXG5cbiAgfSxcbiAgaW52YWxpZFRva2VuOiB7XG4gICAgdG9rZW5TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCIne2ZpcnN0VG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCIsXG4gICAgICBwZXJtaXR0ZWQ6IFwiJ3tmaXJzdFRva2VufScgdG9rZW4gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgJ3tzZWNvbmRUb2tlbn0nIHRva2VuKHMpXCJcbiAgICB9LFxuICAgIHRlcm1TZXF1ZW5jZToge1xuICAgICAgcHJvaGliaXRlZDogXCJBIHtmaXJzdFRlcm19IGNhbm5vdCBiZSBmb2xsb3dlZCBieSBhIHtzZWNvbmRUZXJtfVwiLFxuICAgICAgcGVybWl0dGVkOiBcIkEge2ZpcnN0VGVybX0gY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYSB7c2Vjb25kVGVybX1cIlxuICAgIH0sXG4gICAgZG91YmxlOiBcIid7dG9rZW59JyB0b2tlbiBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYW5vdGhlciAne3Rva2VufScgdG9rZW5cIixcbiAgICB1c2VJbnN0ZWFkOiBcIid7YmFkVG9rZW59JyB0b2tlbiBpcyBub3QgYWNjZXB0ZWQuIFVzZSAne2dvb2RUb2tlbn0nIGluc3RlYWRcIixcbiAgICB1bmV4cGVjdGVkOiBcIlVuZXhwZWN0ZWQgJ3t0b2tlbn0nIHRva2VuIGZvdW5kXCJcbiAgfSxcbiAgYnJhY2U6IHtcbiAgICBjdXJseToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAneycgb3BlbiBjdXJseSBicmFjZVwiLFxuICAgICAgbWlzc2luZ0Nsb3NlOiBcIk9wZW4gJ3snIGN1cmx5IGJyYWNlIGlzIG1pc3NpbmcgY2xvc2luZyAnfScgY3VybHkgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICd7fScgY3VybHkgYnJhY2VzXCJcbiAgICB9LFxuICAgIHNxdWFyZToge1xuICAgICAgbWlzc2luZ09wZW46IFwiTWlzc2luZyAnWycgb3BlbiBzcXVhcmUgYnJhY2VcIixcbiAgICAgIG1pc3NpbmdDbG9zZTogXCJPcGVuICdbJyBzcXVhcmUgYnJhY2UgaXMgbWlzc2luZyBjbG9zaW5nICddJyBzcXVhcmUgYnJhY2VcIixcbiAgICAgIGNhbm5vdFdyYXA6IFwiJ3t0b2tlbn0nIHRva2VuIGNhbm5vdCBiZSB3cmFwcGVkIGluICdbXScgc3F1YXJlIGJyYWNlc1wiXG4gICAgfVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICBtaXNzaW5nT3BlbjogXCJNaXNzaW5nL2ludmFsaWQgb3BlbmluZyBzdHJpbmcgJ3txdW90ZX0nIHRva2VuXCIsXG4gICAgbWlzc2luZ0Nsb3NlOiBcIk1pc3NpbmcvaW52YWxpZCBjbG9zaW5nIHN0cmluZyAne3F1b3RlfScgdG9rZW5cIixcbiAgICBtdXN0QmVXcmFwcGVkQnlRdW90ZXM6IFwiU3RyaW5ncyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgbm9uQWxwaGFudW1lcmljOiBcIk5vbi1hbHBoYW51bWVyaWMgdG9rZW4gJ3t0b2tlbn0nIGlzIG5vdCBhbGxvd2VkIG91dHNpZGUgc3RyaW5nIG5vdGF0aW9uXCIsXG4gICAgdW5leHBlY3RlZEtleTogXCJVbmV4cGVjdGVkIGtleSBmb3VuZCBhdCBzdHJpbmcgcG9zaXRpb25cIlxuICB9LFxuICBrZXk6IHtcbiAgICBudW1iZXJBbmRMZXR0ZXJNaXNzaW5nUXVvdGVzOiBcIktleSBiZWdpbm5pbmcgd2l0aCBudW1iZXIgYW5kIGNvbnRhaW5pbmcgbGV0dGVycyBtdXN0IGJlIHdyYXBwZWQgYnkgcXVvdGVzXCIsXG4gICAgc3BhY2VNaXNzaW5nUXVvdGVzOiBcIktleSBjb250YWluaW5nIHNwYWNlIG11c3QgYmUgd3JhcHBlZCBieSBxdW90ZXNcIixcbiAgICB1bmV4cGVjdGVkU3RyaW5nOiBcIlVuZXhwZWN0ZWQgc3RyaW5nIGZvdW5kIGF0IGtleSBwb3NpdGlvblwiXG4gIH0sXG4gIG5vVHJhaWxpbmdPckxlYWRpbmdDb21tYTogXCJUcmFpbGluZyBvciBsZWFkaW5nIGNvbW1hcyBpbiBhcnJheXMgYW5kIG9iamVjdHMgYXJlIG5vdCBwZXJtaXR0ZWRcIlxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-json-editor-ajrm/locale/en.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(obj, key, value) {\n  key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUNoQztBQUNmLFFBQVEsNkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/OTdkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread; }\n/* harmony export */ });\n/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]);\n    });\n  }\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDbEM7QUFDZixrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU0sOERBQWM7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkLmpzPzViMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gXCIuL2RlZmluZVByb3BlcnR5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IE9iamVjdChhcmd1bWVudHNbaV0pIDoge307XG4gICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cy5wdXNoLmFwcGx5KG93bktleXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toPrimitive; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction _toPrimitive(input, hint) {\n  if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUNuQjtBQUNmLE1BQU0sc0RBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJpbWl0aXZlLmpzPzQxY2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toPropertyKey; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction _toPropertyKey(arg) {\n  var key = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arg, \"string\");\n  return (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key) === \"symbol\" ? key : String(key);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNTO0FBQzVCO0FBQ2YsWUFBWSwyREFBVztBQUN2QixTQUFTLHNEQUFPO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzP2NjN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgdG9QcmltaXRpdmUgZnJvbSBcIi4vdG9QcmltaXRpdmUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzPzYzZDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fzhaojiale%2FLibrary%2FContainers%2Fcom.tencent.xinWeChat%2FData%2FLibrary%2FApplication%20Support%2Fcom.tencent.xinWeChat%2F2.0b4.0.9%2Fb065ac55dfa93c168bb482c8fdccd19e%2FMessage%2FMessageTemp%2F3cfd51035ae532f90f7e60bef55f8b76%2FFile%2Fdouyin-manage%2Fsrc%2Fapp%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);